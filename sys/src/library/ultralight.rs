/* automatically generated by rust-bindgen 0.70.1 */

use crate::defines::*;

#[derive(Clone)]
pub struct Ultralight {
    #[cfg(feature = "loaded")]
    __library: Option<::std::sync::Arc<::libloading::Library>>,
    pub JSEvaluateScript: unsafe extern "C" fn(
        ctx: JSContextRef,
        script: JSStringRef,
        thisObject: JSObjectRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
    pub JSCheckScriptSyntax: unsafe extern "C" fn(
        ctx: JSContextRef,
        script: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSGarbageCollect: unsafe extern "C" fn(ctx: JSContextRef),
    pub JSValueGetType: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> JSType,
    pub JSValueIsUndefined: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsNull: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsBoolean: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsNumber: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsString: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsSymbol: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsObject: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsObjectOfClass:
        unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef, jsClass: JSClassRef) -> bool,
    pub JSValueIsArray: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueIsDate: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueGetTypedArrayType: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType,
    pub JSValueIsEqual: unsafe extern "C" fn(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSValueIsStrictEqual:
        unsafe extern "C" fn(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool,
    pub JSValueIsInstanceOfConstructor: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSValueMakeUndefined: unsafe extern "C" fn(ctx: JSContextRef) -> JSValueRef,
    pub JSValueMakeNull: unsafe extern "C" fn(ctx: JSContextRef) -> JSValueRef,
    pub JSValueMakeBoolean: unsafe extern "C" fn(ctx: JSContextRef, boolean: bool) -> JSValueRef,
    pub JSValueMakeNumber: unsafe extern "C" fn(ctx: JSContextRef, number: f64) -> JSValueRef,
    pub JSValueMakeString:
        unsafe extern "C" fn(ctx: JSContextRef, string: JSStringRef) -> JSValueRef,
    pub JSValueMakeSymbol:
        unsafe extern "C" fn(ctx: JSContextRef, description: JSStringRef) -> JSValueRef,
    pub JSValueMakeFromJSONString:
        unsafe extern "C" fn(ctx: JSContextRef, string: JSStringRef) -> JSValueRef,
    pub JSValueCreateJSONString: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef,
    pub JSValueToBoolean: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef) -> bool,
    pub JSValueToNumber: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> f64,
    pub JSValueToStringCopy: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef,
    pub JSValueToObject: unsafe extern "C" fn(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSValueProtect: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef),
    pub JSValueUnprotect: unsafe extern "C" fn(ctx: JSContextRef, value: JSValueRef),
    pub JSClassCreate: unsafe extern "C" fn(definition: *const JSClassDefinition) -> JSClassRef,
    pub JSClassRetain: unsafe extern "C" fn(jsClass: JSClassRef) -> JSClassRef,
    pub JSClassRelease: unsafe extern "C" fn(jsClass: JSClassRef),
    pub JSObjectMake: unsafe extern "C" fn(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        data: *mut ::std::os::raw::c_void,
    ) -> JSObjectRef,
    pub JSObjectMakeFunctionWithCallback: unsafe extern "C" fn(
        ctx: JSContextRef,
        name: JSStringRef,
        callAsFunction: JSObjectCallAsFunctionCallback,
    ) -> JSObjectRef,
    pub JSObjectMakeConstructor: unsafe extern "C" fn(
        ctx: JSContextRef,
        jsClass: JSClassRef,
        callAsConstructor: JSObjectCallAsConstructorCallback,
    ) -> JSObjectRef,
    pub JSObjectMakeArray: unsafe extern "C" fn(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeDate: unsafe extern "C" fn(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeError: unsafe extern "C" fn(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeRegExp: unsafe extern "C" fn(
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeDeferredPromise: unsafe extern "C" fn(
        ctx: JSContextRef,
        resolve: *mut JSObjectRef,
        reject: *mut JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeFunction: unsafe extern "C" fn(
        ctx: JSContextRef,
        name: JSStringRef,
        parameterCount: ::std::os::raw::c_uint,
        parameterNames: *const JSStringRef,
        body: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectGetPrototype:
        unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef) -> JSValueRef,
    pub JSObjectSetPrototype:
        unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef, value: JSValueRef),
    pub JSObjectHasProperty: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool,
    pub JSObjectGetProperty: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
    pub JSObjectSetProperty: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    ),
    pub JSObjectDeleteProperty: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSObjectHasPropertyForKey: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSObjectGetPropertyForKey: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
    pub JSObjectSetPropertyForKey: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    ),
    pub JSObjectDeletePropertyForKey: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
    pub JSObjectGetPropertyAtIndex: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
    pub JSObjectSetPropertyAtIndex: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ),
    pub JSObjectGetPrivate:
        unsafe extern "C" fn(object: JSObjectRef) -> *mut ::std::os::raw::c_void,
    pub JSObjectSetPrivate:
        unsafe extern "C" fn(object: JSObjectRef, data: *mut ::std::os::raw::c_void) -> bool,
    pub JSObjectIsFunction: unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef) -> bool,
    pub JSObjectCallAsFunction: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
    pub JSObjectIsConstructor: unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef) -> bool,
    pub JSObjectCallAsConstructor: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectCopyPropertyNames:
        unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef) -> JSPropertyNameArrayRef,
    pub JSPropertyNameArrayRetain:
        unsafe extern "C" fn(array: JSPropertyNameArrayRef) -> JSPropertyNameArrayRef,
    pub JSPropertyNameArrayRelease: unsafe extern "C" fn(array: JSPropertyNameArrayRef),
    pub JSPropertyNameArrayGetCount: unsafe extern "C" fn(array: JSPropertyNameArrayRef) -> usize,
    pub JSPropertyNameArrayGetNameAtIndex:
        unsafe extern "C" fn(array: JSPropertyNameArrayRef, index: usize) -> JSStringRef,
    pub JSPropertyNameAccumulatorAddName:
        unsafe extern "C" fn(accumulator: JSPropertyNameAccumulatorRef, propertyName: JSStringRef),
    pub JSContextGroupCreate: unsafe extern "C" fn() -> JSContextGroupRef,
    pub JSContextGroupRetain: unsafe extern "C" fn(group: JSContextGroupRef) -> JSContextGroupRef,
    pub JSContextGroupRelease: unsafe extern "C" fn(group: JSContextGroupRef),
    pub JSGlobalContextCreate:
        unsafe extern "C" fn(globalObjectClass: JSClassRef) -> JSGlobalContextRef,
    pub JSGlobalContextCreateInGroup: unsafe extern "C" fn(
        group: JSContextGroupRef,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef,
    pub JSGlobalContextRetain: unsafe extern "C" fn(ctx: JSGlobalContextRef) -> JSGlobalContextRef,
    pub JSGlobalContextRelease: unsafe extern "C" fn(ctx: JSGlobalContextRef),
    pub JSContextGetGlobalObject: unsafe extern "C" fn(ctx: JSContextRef) -> JSObjectRef,
    pub JSContextGetGroup: unsafe extern "C" fn(ctx: JSContextRef) -> JSContextGroupRef,
    pub JSContextGetGlobalContext: unsafe extern "C" fn(ctx: JSContextRef) -> JSGlobalContextRef,
    pub JSGlobalContextCopyName: unsafe extern "C" fn(ctx: JSGlobalContextRef) -> JSStringRef,
    pub JSGlobalContextSetName: unsafe extern "C" fn(ctx: JSGlobalContextRef, name: JSStringRef),
    pub JSGlobalContextIsInspectable: unsafe extern "C" fn(ctx: JSGlobalContextRef) -> bool,
    pub JSGlobalContextSetInspectable:
        unsafe extern "C" fn(ctx: JSGlobalContextRef, inspectable: bool),
    pub JSStringCreateWithCharacters:
        unsafe extern "C" fn(chars: *const JSChar, numChars: usize) -> JSStringRef,
    pub JSStringCreateWithUTF8CString:
        unsafe extern "C" fn(string: *const ::std::os::raw::c_char) -> JSStringRef,
    pub JSStringRetain: unsafe extern "C" fn(string: JSStringRef) -> JSStringRef,
    pub JSStringRelease: unsafe extern "C" fn(string: JSStringRef),
    pub JSStringGetLength: unsafe extern "C" fn(string: JSStringRef) -> usize,
    pub JSStringGetCharactersPtr: unsafe extern "C" fn(string: JSStringRef) -> *const JSChar,
    pub JSStringGetMaximumUTF8CStringSize: unsafe extern "C" fn(string: JSStringRef) -> usize,
    pub JSStringGetUTF8CString: unsafe extern "C" fn(
        string: JSStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> usize,
    pub JSStringIsEqual: unsafe extern "C" fn(a: JSStringRef, b: JSStringRef) -> bool,
    pub JSStringIsEqualToUTF8CString:
        unsafe extern "C" fn(a: JSStringRef, b: *const ::std::os::raw::c_char) -> bool,
    pub JSObjectMakeTypedArray: unsafe extern "C" fn(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeTypedArrayWithBytesNoCopy: unsafe extern "C" fn(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeTypedArrayWithArrayBuffer: unsafe extern "C" fn(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeTypedArrayWithArrayBufferAndOffset: unsafe extern "C" fn(
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        byteOffset: usize,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectGetTypedArrayBytesPtr: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void,
    pub JSObjectGetTypedArrayLength: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize,
    pub JSObjectGetTypedArrayByteLength: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize,
    pub JSObjectGetTypedArrayByteOffset: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize,
    pub JSObjectGetTypedArrayBuffer: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectMakeArrayBufferWithBytesNoCopy: unsafe extern "C" fn(
        ctx: JSContextRef,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
    pub JSObjectGetArrayBufferBytesPtr: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void,
    pub JSObjectGetArrayBufferByteLength: unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize,
    pub ulVersionString: unsafe extern "C" fn() -> *const ::std::os::raw::c_char,
    pub ulVersionMajor: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub ulVersionMinor: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub ulVersionPatch: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub ulWebKitVersionString: unsafe extern "C" fn() -> *const ::std::os::raw::c_char,
    pub ulCreateEmptyBitmap: unsafe extern "C" fn() -> ULBitmap,
    pub ulCreateBitmap: unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
    ) -> ULBitmap,
    pub ulCreateBitmapFromPixels: unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
        row_bytes: ::std::os::raw::c_uint,
        pixels: *const ::std::os::raw::c_void,
        size: usize,
        should_copy: bool,
    ) -> ULBitmap,
    pub ulCreateBitmapFromCopy: unsafe extern "C" fn(existing_bitmap: ULBitmap) -> ULBitmap,
    pub ulDestroyBitmap: unsafe extern "C" fn(bitmap: ULBitmap),
    pub ulBitmapGetWidth: unsafe extern "C" fn(bitmap: ULBitmap) -> ::std::os::raw::c_uint,
    pub ulBitmapGetHeight: unsafe extern "C" fn(bitmap: ULBitmap) -> ::std::os::raw::c_uint,
    pub ulBitmapGetFormat: unsafe extern "C" fn(bitmap: ULBitmap) -> ULBitmapFormat,
    pub ulBitmapGetBpp: unsafe extern "C" fn(bitmap: ULBitmap) -> ::std::os::raw::c_uint,
    pub ulBitmapGetRowBytes: unsafe extern "C" fn(bitmap: ULBitmap) -> ::std::os::raw::c_uint,
    pub ulBitmapGetSize: unsafe extern "C" fn(bitmap: ULBitmap) -> usize,
    pub ulBitmapOwnsPixels: unsafe extern "C" fn(bitmap: ULBitmap) -> bool,
    pub ulBitmapLockPixels: unsafe extern "C" fn(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void,
    pub ulBitmapUnlockPixels: unsafe extern "C" fn(bitmap: ULBitmap),
    pub ulBitmapRawPixels: unsafe extern "C" fn(bitmap: ULBitmap) -> *mut ::std::os::raw::c_void,
    pub ulBitmapIsEmpty: unsafe extern "C" fn(bitmap: ULBitmap) -> bool,
    pub ulBitmapErase: unsafe extern "C" fn(bitmap: ULBitmap),
    pub ulBitmapWritePNG:
        unsafe extern "C" fn(bitmap: ULBitmap, path: *const ::std::os::raw::c_char) -> bool,
    pub ulBitmapSwapRedBlueChannels: unsafe extern "C" fn(bitmap: ULBitmap),
    pub ulCreateBuffer: unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
        destruction_callback: ulDestroyBufferCallback,
    ) -> ULBuffer,
    pub ulCreateBufferFromCopy:
        unsafe extern "C" fn(data: *const ::std::os::raw::c_void, size: usize) -> ULBuffer,
    pub ulDestroyBuffer: unsafe extern "C" fn(buffer: ULBuffer),
    pub ulBufferGetData: unsafe extern "C" fn(buffer: ULBuffer) -> *mut ::std::os::raw::c_void,
    pub ulBufferGetSize: unsafe extern "C" fn(buffer: ULBuffer) -> usize,
    pub ulBufferGetUserData: unsafe extern "C" fn(buffer: ULBuffer) -> *mut ::std::os::raw::c_void,
    pub ulBufferOwnsData: unsafe extern "C" fn(buffer: ULBuffer) -> bool,
    pub ulCreateConfig: unsafe extern "C" fn() -> ULConfig,
    pub ulDestroyConfig: unsafe extern "C" fn(config: ULConfig),
    pub ulConfigSetCachePath: unsafe extern "C" fn(config: ULConfig, cache_path: ULString),
    pub ulConfigSetResourcePathPrefix:
        unsafe extern "C" fn(config: ULConfig, resource_path_prefix: ULString),
    pub ulConfigSetFaceWinding: unsafe extern "C" fn(config: ULConfig, winding: ULFaceWinding),
    pub ulConfigSetFontHinting: unsafe extern "C" fn(config: ULConfig, font_hinting: ULFontHinting),
    pub ulConfigSetFontGamma: unsafe extern "C" fn(config: ULConfig, font_gamma: f64),
    pub ulConfigSetUserStylesheet: unsafe extern "C" fn(config: ULConfig, css_string: ULString),
    pub ulConfigSetForceRepaint: unsafe extern "C" fn(config: ULConfig, enabled: bool),
    pub ulConfigSetAnimationTimerDelay: unsafe extern "C" fn(config: ULConfig, delay: f64),
    pub ulConfigSetScrollTimerDelay: unsafe extern "C" fn(config: ULConfig, delay: f64),
    pub ulConfigSetRecycleDelay: unsafe extern "C" fn(config: ULConfig, delay: f64),
    pub ulConfigSetMemoryCacheSize:
        unsafe extern "C" fn(config: ULConfig, size: ::std::os::raw::c_uint),
    pub ulConfigSetPageCacheSize:
        unsafe extern "C" fn(config: ULConfig, size: ::std::os::raw::c_uint),
    pub ulConfigSetOverrideRAMSize:
        unsafe extern "C" fn(config: ULConfig, size: ::std::os::raw::c_uint),
    pub ulConfigSetMinLargeHeapSize:
        unsafe extern "C" fn(config: ULConfig, size: ::std::os::raw::c_uint),
    pub ulConfigSetMinSmallHeapSize:
        unsafe extern "C" fn(config: ULConfig, size: ::std::os::raw::c_uint),
    pub ulConfigSetNumRendererThreads:
        unsafe extern "C" fn(config: ULConfig, num_renderer_threads: ::std::os::raw::c_uint),
    pub ulConfigSetMaxUpdateTime: unsafe extern "C" fn(config: ULConfig, max_update_time: f64),
    pub ulConfigSetBitmapAlignment:
        unsafe extern "C" fn(config: ULConfig, bitmap_alignment: ::std::os::raw::c_uint),
    pub ulCreateString: unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> ULString,
    pub ulCreateStringUTF8:
        unsafe extern "C" fn(str_: *const ::std::os::raw::c_char, len: usize) -> ULString,
    pub ulCreateStringUTF16: unsafe extern "C" fn(str_: *mut ULChar16, len: usize) -> ULString,
    pub ulCreateStringFromCopy: unsafe extern "C" fn(str_: ULString) -> ULString,
    pub ulDestroyString: unsafe extern "C" fn(str_: ULString),
    pub ulStringGetData: unsafe extern "C" fn(str_: ULString) -> *mut ::std::os::raw::c_char,
    pub ulStringGetLength: unsafe extern "C" fn(str_: ULString) -> usize,
    pub ulStringIsEmpty: unsafe extern "C" fn(str_: ULString) -> bool,
    pub ulStringAssignString: unsafe extern "C" fn(str_: ULString, new_str: ULString),
    pub ulStringAssignCString:
        unsafe extern "C" fn(str_: ULString, c_str: *const ::std::os::raw::c_char),
    pub ulFontFileCreateFromFilePath: unsafe extern "C" fn(file_path: ULString) -> ULFontFile,
    pub ulFontFileCreateFromBuffer: unsafe extern "C" fn(buffer: ULBuffer) -> ULFontFile,
    pub ulDestroyFontFile: unsafe extern "C" fn(font_file: ULFontFile),
    pub ulRectIsEmpty: unsafe extern "C" fn(rect: ULRect) -> bool,
    pub ulRectMakeEmpty: unsafe extern "C" fn() -> ULRect,
    pub ulIntRectIsEmpty: unsafe extern "C" fn(rect: ULIntRect) -> bool,
    pub ulIntRectMakeEmpty: unsafe extern "C" fn() -> ULIntRect,
    pub ulApplyProjection: unsafe extern "C" fn(
        transform: ULMatrix4x4,
        viewport_width: f32,
        viewport_height: f32,
        flip_y: bool,
    ) -> ULMatrix4x4,
    pub ulCreateImageSourceFromTexture: unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        texture_id: ::std::os::raw::c_uint,
        texture_uv: ULRect,
        bitmap: ULBitmap,
    ) -> ULImageSource,
    pub ulCreateImageSourceFromBitmap: unsafe extern "C" fn(bitmap: ULBitmap) -> ULImageSource,
    pub ulDestroyImageSource: unsafe extern "C" fn(image_source: ULImageSource),
    pub ulImageSourceInvalidate: unsafe extern "C" fn(image_source: ULImageSource),
    pub ulImageSourceProviderAddImageSource:
        unsafe extern "C" fn(id: ULString, image_source: ULImageSource),
    pub ulImageSourceProviderRemoveImageSource: unsafe extern "C" fn(id: ULString),
    pub ulCreateKeyEvent: unsafe extern "C" fn(
        type_: ULKeyEventType,
        modifiers: ::std::os::raw::c_uint,
        virtual_key_code: ::std::os::raw::c_int,
        native_key_code: ::std::os::raw::c_int,
        text: ULString,
        unmodified_text: ULString,
        is_keypad: bool,
        is_auto_repeat: bool,
        is_system_key: bool,
    ) -> ULKeyEvent,
    pub ulDestroyKeyEvent: unsafe extern "C" fn(evt: ULKeyEvent),
    pub ulCreateMouseEvent: unsafe extern "C" fn(
        type_: ULMouseEventType,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        button: ULMouseButton,
    ) -> ULMouseEvent,
    pub ulDestroyMouseEvent: unsafe extern "C" fn(evt: ULMouseEvent),
    pub ulSurfaceGetWidth: unsafe extern "C" fn(surface: ULSurface) -> ::std::os::raw::c_uint,
    pub ulSurfaceGetHeight: unsafe extern "C" fn(surface: ULSurface) -> ::std::os::raw::c_uint,
    pub ulSurfaceGetRowBytes: unsafe extern "C" fn(surface: ULSurface) -> ::std::os::raw::c_uint,
    pub ulSurfaceGetSize: unsafe extern "C" fn(surface: ULSurface) -> usize,
    pub ulSurfaceLockPixels:
        unsafe extern "C" fn(surface: ULSurface) -> *mut ::std::os::raw::c_void,
    pub ulSurfaceUnlockPixels: unsafe extern "C" fn(surface: ULSurface),
    pub ulSurfaceResize: unsafe extern "C" fn(
        surface: ULSurface,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
    pub ulSurfaceSetDirtyBounds: unsafe extern "C" fn(surface: ULSurface, bounds: ULIntRect),
    pub ulSurfaceGetDirtyBounds: unsafe extern "C" fn(surface: ULSurface) -> ULIntRect,
    pub ulSurfaceClearDirtyBounds: unsafe extern "C" fn(surface: ULSurface),
    pub ulSurfaceGetUserData:
        unsafe extern "C" fn(surface: ULSurface) -> *mut ::std::os::raw::c_void,
    pub ulBitmapSurfaceGetBitmap: unsafe extern "C" fn(surface: ULBitmapSurface) -> ULBitmap,
    pub ulPlatformSetLogger: unsafe extern "C" fn(logger: ULLogger),
    pub ulPlatformSetFileSystem: unsafe extern "C" fn(file_system: ULFileSystem),
    pub ulPlatformSetSurfaceDefinition:
        unsafe extern "C" fn(surface_definition: ULSurfaceDefinition),
    pub ulPlatformSetGPUDriver: unsafe extern "C" fn(gpu_driver: ULGPUDriver),
    pub ulPlatformSetClipboard: unsafe extern "C" fn(clipboard: ULClipboard),
    pub ulCreateRenderer: unsafe extern "C" fn(config: ULConfig) -> ULRenderer,
    pub ulDestroyRenderer: unsafe extern "C" fn(renderer: ULRenderer),
    pub ulUpdate: unsafe extern "C" fn(renderer: ULRenderer),
    pub ulRefreshDisplay:
        unsafe extern "C" fn(renderer: ULRenderer, display_id: ::std::os::raw::c_uint),
    pub ulRender: unsafe extern "C" fn(renderer: ULRenderer),
    pub ulPurgeMemory: unsafe extern "C" fn(renderer: ULRenderer),
    pub ulLogMemoryUsage: unsafe extern "C" fn(renderer: ULRenderer),
    pub ulStartRemoteInspectorServer: unsafe extern "C" fn(
        renderer: ULRenderer,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    ) -> bool,
    pub ulSetGamepadDetails: unsafe extern "C" fn(
        renderer: ULRenderer,
        index: ::std::os::raw::c_uint,
        id: ULString,
        axis_count: ::std::os::raw::c_uint,
        button_count: ::std::os::raw::c_uint,
    ),
    pub ulFireGamepadEvent: unsafe extern "C" fn(renderer: ULRenderer, evt: ULGamepadEvent),
    pub ulFireGamepadAxisEvent: unsafe extern "C" fn(renderer: ULRenderer, evt: ULGamepadAxisEvent),
    pub ulFireGamepadButtonEvent:
        unsafe extern "C" fn(renderer: ULRenderer, evt: ULGamepadButtonEvent),
    pub ulCreateScrollEvent: unsafe extern "C" fn(
        type_: ULScrollEventType,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> ULScrollEvent,
    pub ulDestroyScrollEvent: unsafe extern "C" fn(evt: ULScrollEvent),
    pub ulCreateGamepadEvent: unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        type_: ULGamepadEventType,
    ) -> ULGamepadEvent,
    pub ulDestroyGamepadEvent: unsafe extern "C" fn(evt: ULGamepadEvent),
    pub ulCreateGamepadAxisEvent: unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        axis_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadAxisEvent,
    pub ulDestroyGamepadAxisEvent: unsafe extern "C" fn(evt: ULGamepadAxisEvent),
    pub ulCreateGamepadButtonEvent: unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        button_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadButtonEvent,
    pub ulDestroyGamepadButtonEvent: unsafe extern "C" fn(evt: ULGamepadButtonEvent),
    pub ulCreateSession: unsafe extern "C" fn(
        renderer: ULRenderer,
        is_persistent: bool,
        name: ULString,
    ) -> ULSession,
    pub ulDestroySession: unsafe extern "C" fn(session: ULSession),
    pub ulDefaultSession: unsafe extern "C" fn(renderer: ULRenderer) -> ULSession,
    pub ulSessionIsPersistent: unsafe extern "C" fn(session: ULSession) -> bool,
    pub ulSessionGetName: unsafe extern "C" fn(session: ULSession) -> ULString,
    pub ulSessionGetId: unsafe extern "C" fn(session: ULSession) -> ::std::os::raw::c_ulonglong,
    pub ulSessionGetDiskPath: unsafe extern "C" fn(session: ULSession) -> ULString,
    pub ulCreateViewConfig: unsafe extern "C" fn() -> ULViewConfig,
    pub ulDestroyViewConfig: unsafe extern "C" fn(config: ULViewConfig),
    pub ulViewConfigSetDisplayId:
        unsafe extern "C" fn(config: ULViewConfig, display_id: ::std::os::raw::c_uint),
    pub ulViewConfigSetIsAccelerated:
        unsafe extern "C" fn(config: ULViewConfig, is_accelerated: bool),
    pub ulViewConfigSetIsTransparent:
        unsafe extern "C" fn(config: ULViewConfig, is_transparent: bool),
    pub ulViewConfigSetInitialDeviceScale:
        unsafe extern "C" fn(config: ULViewConfig, initial_device_scale: f64),
    pub ulViewConfigSetInitialFocus: unsafe extern "C" fn(config: ULViewConfig, is_focused: bool),
    pub ulViewConfigSetEnableImages: unsafe extern "C" fn(config: ULViewConfig, enabled: bool),
    pub ulViewConfigSetEnableJavaScript: unsafe extern "C" fn(config: ULViewConfig, enabled: bool),
    pub ulViewConfigSetFontFamilyStandard:
        unsafe extern "C" fn(config: ULViewConfig, font_name: ULString),
    pub ulViewConfigSetFontFamilyFixed:
        unsafe extern "C" fn(config: ULViewConfig, font_name: ULString),
    pub ulViewConfigSetFontFamilySerif:
        unsafe extern "C" fn(config: ULViewConfig, font_name: ULString),
    pub ulViewConfigSetFontFamilySansSerif:
        unsafe extern "C" fn(config: ULViewConfig, font_name: ULString),
    pub ulViewConfigSetUserAgent:
        unsafe extern "C" fn(config: ULViewConfig, agent_string: ULString),
    pub ulCreateView: unsafe extern "C" fn(
        renderer: ULRenderer,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        view_config: ULViewConfig,
        session: ULSession,
    ) -> ULView,
    pub ulDestroyView: unsafe extern "C" fn(view: ULView),
    pub ulViewGetURL: unsafe extern "C" fn(view: ULView) -> ULString,
    pub ulViewGetTitle: unsafe extern "C" fn(view: ULView) -> ULString,
    pub ulViewGetWidth: unsafe extern "C" fn(view: ULView) -> ::std::os::raw::c_uint,
    pub ulViewGetHeight: unsafe extern "C" fn(view: ULView) -> ::std::os::raw::c_uint,
    pub ulViewGetDisplayId: unsafe extern "C" fn(view: ULView) -> ::std::os::raw::c_uint,
    pub ulViewSetDisplayId: unsafe extern "C" fn(view: ULView, display_id: ::std::os::raw::c_uint),
    pub ulViewGetDeviceScale: unsafe extern "C" fn(view: ULView) -> f64,
    pub ulViewSetDeviceScale: unsafe extern "C" fn(view: ULView, scale: f64),
    pub ulViewIsAccelerated: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewIsTransparent: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewIsLoading: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewGetRenderTarget: unsafe extern "C" fn(view: ULView) -> ULRenderTarget,
    pub ulViewGetSurface: unsafe extern "C" fn(view: ULView) -> ULSurface,
    pub ulViewLoadHTML: unsafe extern "C" fn(view: ULView, html_string: ULString),
    pub ulViewLoadURL: unsafe extern "C" fn(view: ULView, url_string: ULString),
    pub ulViewResize: unsafe extern "C" fn(
        view: ULView,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
    pub ulViewLockJSContext: unsafe extern "C" fn(view: ULView) -> JSContextRef,
    pub ulViewUnlockJSContext: unsafe extern "C" fn(view: ULView),
    pub ulViewEvaluateScript: unsafe extern "C" fn(
        view: ULView,
        js_string: ULString,
        exception: *mut ULString,
    ) -> ULString,
    pub ulViewCanGoBack: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewCanGoForward: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewGoBack: unsafe extern "C" fn(view: ULView),
    pub ulViewGoForward: unsafe extern "C" fn(view: ULView),
    pub ulViewGoToHistoryOffset: unsafe extern "C" fn(view: ULView, offset: ::std::os::raw::c_int),
    pub ulViewReload: unsafe extern "C" fn(view: ULView),
    pub ulViewStop: unsafe extern "C" fn(view: ULView),
    pub ulViewFocus: unsafe extern "C" fn(view: ULView),
    pub ulViewUnfocus: unsafe extern "C" fn(view: ULView),
    pub ulViewHasFocus: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewHasInputFocus: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewFireKeyEvent: unsafe extern "C" fn(view: ULView, key_event: ULKeyEvent),
    pub ulViewFireMouseEvent: unsafe extern "C" fn(view: ULView, mouse_event: ULMouseEvent),
    pub ulViewFireScrollEvent: unsafe extern "C" fn(view: ULView, scroll_event: ULScrollEvent),
    pub ulViewSetChangeTitleCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULChangeTitleCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetChangeURLCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULChangeURLCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetChangeTooltipCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULChangeTooltipCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetChangeCursorCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULChangeCursorCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetAddConsoleMessageCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULAddConsoleMessageCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetCreateChildViewCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULCreateChildViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetCreateInspectorViewCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULCreateInspectorViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetBeginLoadingCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULBeginLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetFinishLoadingCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULFinishLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetFailLoadingCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULFailLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetWindowObjectReadyCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULWindowObjectReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetDOMReadyCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULDOMReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetUpdateHistoryCallback: unsafe extern "C" fn(
        view: ULView,
        callback: ULUpdateHistoryCallback,
        user_data: *mut ::std::os::raw::c_void,
    ),
    pub ulViewSetNeedsPaint: unsafe extern "C" fn(view: ULView, needs_paint: bool),
    pub ulViewGetNeedsPaint: unsafe extern "C" fn(view: ULView) -> bool,
    pub ulViewCreateLocalInspectorView: unsafe extern "C" fn(view: ULView),
}
impl Ultralight {
    #[cfg(feature = "linked")]
    #[cfg_attr(docsrs, doc(cfg(feature = "linked")))]
    pub const fn linked() -> Self {
        Self {
            #[cfg(feature = "loaded")]
            __library: None,
            JSEvaluateScript: crate::linked::JSEvaluateScript,
            JSCheckScriptSyntax: crate::linked::JSCheckScriptSyntax,
            JSGarbageCollect: crate::linked::JSGarbageCollect,
            JSValueGetType: crate::linked::JSValueGetType,
            JSValueIsUndefined: crate::linked::JSValueIsUndefined,
            JSValueIsNull: crate::linked::JSValueIsNull,
            JSValueIsBoolean: crate::linked::JSValueIsBoolean,
            JSValueIsNumber: crate::linked::JSValueIsNumber,
            JSValueIsString: crate::linked::JSValueIsString,
            JSValueIsSymbol: crate::linked::JSValueIsSymbol,
            JSValueIsObject: crate::linked::JSValueIsObject,
            JSValueIsObjectOfClass: crate::linked::JSValueIsObjectOfClass,
            JSValueIsArray: crate::linked::JSValueIsArray,
            JSValueIsDate: crate::linked::JSValueIsDate,
            JSValueGetTypedArrayType: crate::linked::JSValueGetTypedArrayType,
            JSValueIsEqual: crate::linked::JSValueIsEqual,
            JSValueIsStrictEqual: crate::linked::JSValueIsStrictEqual,
            JSValueIsInstanceOfConstructor: crate::linked::JSValueIsInstanceOfConstructor,
            JSValueMakeUndefined: crate::linked::JSValueMakeUndefined,
            JSValueMakeNull: crate::linked::JSValueMakeNull,
            JSValueMakeBoolean: crate::linked::JSValueMakeBoolean,
            JSValueMakeNumber: crate::linked::JSValueMakeNumber,
            JSValueMakeString: crate::linked::JSValueMakeString,
            JSValueMakeSymbol: crate::linked::JSValueMakeSymbol,
            JSValueMakeFromJSONString: crate::linked::JSValueMakeFromJSONString,
            JSValueCreateJSONString: crate::linked::JSValueCreateJSONString,
            JSValueToBoolean: crate::linked::JSValueToBoolean,
            JSValueToNumber: crate::linked::JSValueToNumber,
            JSValueToStringCopy: crate::linked::JSValueToStringCopy,
            JSValueToObject: crate::linked::JSValueToObject,
            JSValueProtect: crate::linked::JSValueProtect,
            JSValueUnprotect: crate::linked::JSValueUnprotect,
            JSClassCreate: crate::linked::JSClassCreate,
            JSClassRetain: crate::linked::JSClassRetain,
            JSClassRelease: crate::linked::JSClassRelease,
            JSObjectMake: crate::linked::JSObjectMake,
            JSObjectMakeFunctionWithCallback: crate::linked::JSObjectMakeFunctionWithCallback,
            JSObjectMakeConstructor: crate::linked::JSObjectMakeConstructor,
            JSObjectMakeArray: crate::linked::JSObjectMakeArray,
            JSObjectMakeDate: crate::linked::JSObjectMakeDate,
            JSObjectMakeError: crate::linked::JSObjectMakeError,
            JSObjectMakeRegExp: crate::linked::JSObjectMakeRegExp,
            JSObjectMakeDeferredPromise: crate::linked::JSObjectMakeDeferredPromise,
            JSObjectMakeFunction: crate::linked::JSObjectMakeFunction,
            JSObjectGetPrototype: crate::linked::JSObjectGetPrototype,
            JSObjectSetPrototype: crate::linked::JSObjectSetPrototype,
            JSObjectHasProperty: crate::linked::JSObjectHasProperty,
            JSObjectGetProperty: crate::linked::JSObjectGetProperty,
            JSObjectSetProperty: crate::linked::JSObjectSetProperty,
            JSObjectDeleteProperty: crate::linked::JSObjectDeleteProperty,
            JSObjectHasPropertyForKey: crate::linked::JSObjectHasPropertyForKey,
            JSObjectGetPropertyForKey: crate::linked::JSObjectGetPropertyForKey,
            JSObjectSetPropertyForKey: crate::linked::JSObjectSetPropertyForKey,
            JSObjectDeletePropertyForKey: crate::linked::JSObjectDeletePropertyForKey,
            JSObjectGetPropertyAtIndex: crate::linked::JSObjectGetPropertyAtIndex,
            JSObjectSetPropertyAtIndex: crate::linked::JSObjectSetPropertyAtIndex,
            JSObjectGetPrivate: crate::linked::JSObjectGetPrivate,
            JSObjectSetPrivate: crate::linked::JSObjectSetPrivate,
            JSObjectIsFunction: crate::linked::JSObjectIsFunction,
            JSObjectCallAsFunction: crate::linked::JSObjectCallAsFunction,
            JSObjectIsConstructor: crate::linked::JSObjectIsConstructor,
            JSObjectCallAsConstructor: crate::linked::JSObjectCallAsConstructor,
            JSObjectCopyPropertyNames: crate::linked::JSObjectCopyPropertyNames,
            JSPropertyNameArrayRetain: crate::linked::JSPropertyNameArrayRetain,
            JSPropertyNameArrayRelease: crate::linked::JSPropertyNameArrayRelease,
            JSPropertyNameArrayGetCount: crate::linked::JSPropertyNameArrayGetCount,
            JSPropertyNameArrayGetNameAtIndex: crate::linked::JSPropertyNameArrayGetNameAtIndex,
            JSPropertyNameAccumulatorAddName: crate::linked::JSPropertyNameAccumulatorAddName,
            JSContextGroupCreate: crate::linked::JSContextGroupCreate,
            JSContextGroupRetain: crate::linked::JSContextGroupRetain,
            JSContextGroupRelease: crate::linked::JSContextGroupRelease,
            JSGlobalContextCreate: crate::linked::JSGlobalContextCreate,
            JSGlobalContextCreateInGroup: crate::linked::JSGlobalContextCreateInGroup,
            JSGlobalContextRetain: crate::linked::JSGlobalContextRetain,
            JSGlobalContextRelease: crate::linked::JSGlobalContextRelease,
            JSContextGetGlobalObject: crate::linked::JSContextGetGlobalObject,
            JSContextGetGroup: crate::linked::JSContextGetGroup,
            JSContextGetGlobalContext: crate::linked::JSContextGetGlobalContext,
            JSGlobalContextCopyName: crate::linked::JSGlobalContextCopyName,
            JSGlobalContextSetName: crate::linked::JSGlobalContextSetName,
            JSGlobalContextIsInspectable: crate::linked::JSGlobalContextIsInspectable,
            JSGlobalContextSetInspectable: crate::linked::JSGlobalContextSetInspectable,
            JSStringCreateWithCharacters: crate::linked::JSStringCreateWithCharacters,
            JSStringCreateWithUTF8CString: crate::linked::JSStringCreateWithUTF8CString,
            JSStringRetain: crate::linked::JSStringRetain,
            JSStringRelease: crate::linked::JSStringRelease,
            JSStringGetLength: crate::linked::JSStringGetLength,
            JSStringGetCharactersPtr: crate::linked::JSStringGetCharactersPtr,
            JSStringGetMaximumUTF8CStringSize: crate::linked::JSStringGetMaximumUTF8CStringSize,
            JSStringGetUTF8CString: crate::linked::JSStringGetUTF8CString,
            JSStringIsEqual: crate::linked::JSStringIsEqual,
            JSStringIsEqualToUTF8CString: crate::linked::JSStringIsEqualToUTF8CString,
            JSObjectMakeTypedArray: crate::linked::JSObjectMakeTypedArray,
            JSObjectMakeTypedArrayWithBytesNoCopy:
                crate::linked::JSObjectMakeTypedArrayWithBytesNoCopy,
            JSObjectMakeTypedArrayWithArrayBuffer:
                crate::linked::JSObjectMakeTypedArrayWithArrayBuffer,
            JSObjectMakeTypedArrayWithArrayBufferAndOffset:
                crate::linked::JSObjectMakeTypedArrayWithArrayBufferAndOffset,
            JSObjectGetTypedArrayBytesPtr: crate::linked::JSObjectGetTypedArrayBytesPtr,
            JSObjectGetTypedArrayLength: crate::linked::JSObjectGetTypedArrayLength,
            JSObjectGetTypedArrayByteLength: crate::linked::JSObjectGetTypedArrayByteLength,
            JSObjectGetTypedArrayByteOffset: crate::linked::JSObjectGetTypedArrayByteOffset,
            JSObjectGetTypedArrayBuffer: crate::linked::JSObjectGetTypedArrayBuffer,
            JSObjectMakeArrayBufferWithBytesNoCopy:
                crate::linked::JSObjectMakeArrayBufferWithBytesNoCopy,
            JSObjectGetArrayBufferBytesPtr: crate::linked::JSObjectGetArrayBufferBytesPtr,
            JSObjectGetArrayBufferByteLength: crate::linked::JSObjectGetArrayBufferByteLength,
            ulVersionString: crate::linked::ulVersionString,
            ulVersionMajor: crate::linked::ulVersionMajor,
            ulVersionMinor: crate::linked::ulVersionMinor,
            ulVersionPatch: crate::linked::ulVersionPatch,
            ulWebKitVersionString: crate::linked::ulWebKitVersionString,
            ulCreateEmptyBitmap: crate::linked::ulCreateEmptyBitmap,
            ulCreateBitmap: crate::linked::ulCreateBitmap,
            ulCreateBitmapFromPixels: crate::linked::ulCreateBitmapFromPixels,
            ulCreateBitmapFromCopy: crate::linked::ulCreateBitmapFromCopy,
            ulDestroyBitmap: crate::linked::ulDestroyBitmap,
            ulBitmapGetWidth: crate::linked::ulBitmapGetWidth,
            ulBitmapGetHeight: crate::linked::ulBitmapGetHeight,
            ulBitmapGetFormat: crate::linked::ulBitmapGetFormat,
            ulBitmapGetBpp: crate::linked::ulBitmapGetBpp,
            ulBitmapGetRowBytes: crate::linked::ulBitmapGetRowBytes,
            ulBitmapGetSize: crate::linked::ulBitmapGetSize,
            ulBitmapOwnsPixels: crate::linked::ulBitmapOwnsPixels,
            ulBitmapLockPixels: crate::linked::ulBitmapLockPixels,
            ulBitmapUnlockPixels: crate::linked::ulBitmapUnlockPixels,
            ulBitmapRawPixels: crate::linked::ulBitmapRawPixels,
            ulBitmapIsEmpty: crate::linked::ulBitmapIsEmpty,
            ulBitmapErase: crate::linked::ulBitmapErase,
            ulBitmapWritePNG: crate::linked::ulBitmapWritePNG,
            ulBitmapSwapRedBlueChannels: crate::linked::ulBitmapSwapRedBlueChannels,
            ulCreateBuffer: crate::linked::ulCreateBuffer,
            ulCreateBufferFromCopy: crate::linked::ulCreateBufferFromCopy,
            ulDestroyBuffer: crate::linked::ulDestroyBuffer,
            ulBufferGetData: crate::linked::ulBufferGetData,
            ulBufferGetSize: crate::linked::ulBufferGetSize,
            ulBufferGetUserData: crate::linked::ulBufferGetUserData,
            ulBufferOwnsData: crate::linked::ulBufferOwnsData,
            ulCreateConfig: crate::linked::ulCreateConfig,
            ulDestroyConfig: crate::linked::ulDestroyConfig,
            ulConfigSetCachePath: crate::linked::ulConfigSetCachePath,
            ulConfigSetResourcePathPrefix: crate::linked::ulConfigSetResourcePathPrefix,
            ulConfigSetFaceWinding: crate::linked::ulConfigSetFaceWinding,
            ulConfigSetFontHinting: crate::linked::ulConfigSetFontHinting,
            ulConfigSetFontGamma: crate::linked::ulConfigSetFontGamma,
            ulConfigSetUserStylesheet: crate::linked::ulConfigSetUserStylesheet,
            ulConfigSetForceRepaint: crate::linked::ulConfigSetForceRepaint,
            ulConfigSetAnimationTimerDelay: crate::linked::ulConfigSetAnimationTimerDelay,
            ulConfigSetScrollTimerDelay: crate::linked::ulConfigSetScrollTimerDelay,
            ulConfigSetRecycleDelay: crate::linked::ulConfigSetRecycleDelay,
            ulConfigSetMemoryCacheSize: crate::linked::ulConfigSetMemoryCacheSize,
            ulConfigSetPageCacheSize: crate::linked::ulConfigSetPageCacheSize,
            ulConfigSetOverrideRAMSize: crate::linked::ulConfigSetOverrideRAMSize,
            ulConfigSetMinLargeHeapSize: crate::linked::ulConfigSetMinLargeHeapSize,
            ulConfigSetMinSmallHeapSize: crate::linked::ulConfigSetMinSmallHeapSize,
            ulConfigSetNumRendererThreads: crate::linked::ulConfigSetNumRendererThreads,
            ulConfigSetMaxUpdateTime: crate::linked::ulConfigSetMaxUpdateTime,
            ulConfigSetBitmapAlignment: crate::linked::ulConfigSetBitmapAlignment,
            ulCreateString: crate::linked::ulCreateString,
            ulCreateStringUTF8: crate::linked::ulCreateStringUTF8,
            ulCreateStringUTF16: crate::linked::ulCreateStringUTF16,
            ulCreateStringFromCopy: crate::linked::ulCreateStringFromCopy,
            ulDestroyString: crate::linked::ulDestroyString,
            ulStringGetData: crate::linked::ulStringGetData,
            ulStringGetLength: crate::linked::ulStringGetLength,
            ulStringIsEmpty: crate::linked::ulStringIsEmpty,
            ulStringAssignString: crate::linked::ulStringAssignString,
            ulStringAssignCString: crate::linked::ulStringAssignCString,
            ulFontFileCreateFromFilePath: crate::linked::ulFontFileCreateFromFilePath,
            ulFontFileCreateFromBuffer: crate::linked::ulFontFileCreateFromBuffer,
            ulDestroyFontFile: crate::linked::ulDestroyFontFile,
            ulRectIsEmpty: crate::linked::ulRectIsEmpty,
            ulRectMakeEmpty: crate::linked::ulRectMakeEmpty,
            ulIntRectIsEmpty: crate::linked::ulIntRectIsEmpty,
            ulIntRectMakeEmpty: crate::linked::ulIntRectMakeEmpty,
            ulApplyProjection: crate::linked::ulApplyProjection,
            ulCreateImageSourceFromTexture: crate::linked::ulCreateImageSourceFromTexture,
            ulCreateImageSourceFromBitmap: crate::linked::ulCreateImageSourceFromBitmap,
            ulDestroyImageSource: crate::linked::ulDestroyImageSource,
            ulImageSourceInvalidate: crate::linked::ulImageSourceInvalidate,
            ulImageSourceProviderAddImageSource: crate::linked::ulImageSourceProviderAddImageSource,
            ulImageSourceProviderRemoveImageSource:
                crate::linked::ulImageSourceProviderRemoveImageSource,
            ulCreateKeyEvent: crate::linked::ulCreateKeyEvent,
            ulDestroyKeyEvent: crate::linked::ulDestroyKeyEvent,
            ulCreateMouseEvent: crate::linked::ulCreateMouseEvent,
            ulDestroyMouseEvent: crate::linked::ulDestroyMouseEvent,
            ulSurfaceGetWidth: crate::linked::ulSurfaceGetWidth,
            ulSurfaceGetHeight: crate::linked::ulSurfaceGetHeight,
            ulSurfaceGetRowBytes: crate::linked::ulSurfaceGetRowBytes,
            ulSurfaceGetSize: crate::linked::ulSurfaceGetSize,
            ulSurfaceLockPixels: crate::linked::ulSurfaceLockPixels,
            ulSurfaceUnlockPixels: crate::linked::ulSurfaceUnlockPixels,
            ulSurfaceResize: crate::linked::ulSurfaceResize,
            ulSurfaceSetDirtyBounds: crate::linked::ulSurfaceSetDirtyBounds,
            ulSurfaceGetDirtyBounds: crate::linked::ulSurfaceGetDirtyBounds,
            ulSurfaceClearDirtyBounds: crate::linked::ulSurfaceClearDirtyBounds,
            ulSurfaceGetUserData: crate::linked::ulSurfaceGetUserData,
            ulBitmapSurfaceGetBitmap: crate::linked::ulBitmapSurfaceGetBitmap,
            ulPlatformSetLogger: crate::linked::ulPlatformSetLogger,
            ulPlatformSetFileSystem: crate::linked::ulPlatformSetFileSystem,
            ulPlatformSetSurfaceDefinition: crate::linked::ulPlatformSetSurfaceDefinition,
            ulPlatformSetGPUDriver: crate::linked::ulPlatformSetGPUDriver,
            ulPlatformSetClipboard: crate::linked::ulPlatformSetClipboard,
            ulCreateRenderer: crate::linked::ulCreateRenderer,
            ulDestroyRenderer: crate::linked::ulDestroyRenderer,
            ulUpdate: crate::linked::ulUpdate,
            ulRefreshDisplay: crate::linked::ulRefreshDisplay,
            ulRender: crate::linked::ulRender,
            ulPurgeMemory: crate::linked::ulPurgeMemory,
            ulLogMemoryUsage: crate::linked::ulLogMemoryUsage,
            ulStartRemoteInspectorServer: crate::linked::ulStartRemoteInspectorServer,
            ulSetGamepadDetails: crate::linked::ulSetGamepadDetails,
            ulFireGamepadEvent: crate::linked::ulFireGamepadEvent,
            ulFireGamepadAxisEvent: crate::linked::ulFireGamepadAxisEvent,
            ulFireGamepadButtonEvent: crate::linked::ulFireGamepadButtonEvent,
            ulCreateScrollEvent: crate::linked::ulCreateScrollEvent,
            ulDestroyScrollEvent: crate::linked::ulDestroyScrollEvent,
            ulCreateGamepadEvent: crate::linked::ulCreateGamepadEvent,
            ulDestroyGamepadEvent: crate::linked::ulDestroyGamepadEvent,
            ulCreateGamepadAxisEvent: crate::linked::ulCreateGamepadAxisEvent,
            ulDestroyGamepadAxisEvent: crate::linked::ulDestroyGamepadAxisEvent,
            ulCreateGamepadButtonEvent: crate::linked::ulCreateGamepadButtonEvent,
            ulDestroyGamepadButtonEvent: crate::linked::ulDestroyGamepadButtonEvent,
            ulCreateSession: crate::linked::ulCreateSession,
            ulDestroySession: crate::linked::ulDestroySession,
            ulDefaultSession: crate::linked::ulDefaultSession,
            ulSessionIsPersistent: crate::linked::ulSessionIsPersistent,
            ulSessionGetName: crate::linked::ulSessionGetName,
            ulSessionGetId: crate::linked::ulSessionGetId,
            ulSessionGetDiskPath: crate::linked::ulSessionGetDiskPath,
            ulCreateViewConfig: crate::linked::ulCreateViewConfig,
            ulDestroyViewConfig: crate::linked::ulDestroyViewConfig,
            ulViewConfigSetDisplayId: crate::linked::ulViewConfigSetDisplayId,
            ulViewConfigSetIsAccelerated: crate::linked::ulViewConfigSetIsAccelerated,
            ulViewConfigSetIsTransparent: crate::linked::ulViewConfigSetIsTransparent,
            ulViewConfigSetInitialDeviceScale: crate::linked::ulViewConfigSetInitialDeviceScale,
            ulViewConfigSetInitialFocus: crate::linked::ulViewConfigSetInitialFocus,
            ulViewConfigSetEnableImages: crate::linked::ulViewConfigSetEnableImages,
            ulViewConfigSetEnableJavaScript: crate::linked::ulViewConfigSetEnableJavaScript,
            ulViewConfigSetFontFamilyStandard: crate::linked::ulViewConfigSetFontFamilyStandard,
            ulViewConfigSetFontFamilyFixed: crate::linked::ulViewConfigSetFontFamilyFixed,
            ulViewConfigSetFontFamilySerif: crate::linked::ulViewConfigSetFontFamilySerif,
            ulViewConfigSetFontFamilySansSerif: crate::linked::ulViewConfigSetFontFamilySansSerif,
            ulViewConfigSetUserAgent: crate::linked::ulViewConfigSetUserAgent,
            ulCreateView: crate::linked::ulCreateView,
            ulDestroyView: crate::linked::ulDestroyView,
            ulViewGetURL: crate::linked::ulViewGetURL,
            ulViewGetTitle: crate::linked::ulViewGetTitle,
            ulViewGetWidth: crate::linked::ulViewGetWidth,
            ulViewGetHeight: crate::linked::ulViewGetHeight,
            ulViewGetDisplayId: crate::linked::ulViewGetDisplayId,
            ulViewSetDisplayId: crate::linked::ulViewSetDisplayId,
            ulViewGetDeviceScale: crate::linked::ulViewGetDeviceScale,
            ulViewSetDeviceScale: crate::linked::ulViewSetDeviceScale,
            ulViewIsAccelerated: crate::linked::ulViewIsAccelerated,
            ulViewIsTransparent: crate::linked::ulViewIsTransparent,
            ulViewIsLoading: crate::linked::ulViewIsLoading,
            ulViewGetRenderTarget: crate::linked::ulViewGetRenderTarget,
            ulViewGetSurface: crate::linked::ulViewGetSurface,
            ulViewLoadHTML: crate::linked::ulViewLoadHTML,
            ulViewLoadURL: crate::linked::ulViewLoadURL,
            ulViewResize: crate::linked::ulViewResize,
            ulViewLockJSContext: crate::linked::ulViewLockJSContext,
            ulViewUnlockJSContext: crate::linked::ulViewUnlockJSContext,
            ulViewEvaluateScript: crate::linked::ulViewEvaluateScript,
            ulViewCanGoBack: crate::linked::ulViewCanGoBack,
            ulViewCanGoForward: crate::linked::ulViewCanGoForward,
            ulViewGoBack: crate::linked::ulViewGoBack,
            ulViewGoForward: crate::linked::ulViewGoForward,
            ulViewGoToHistoryOffset: crate::linked::ulViewGoToHistoryOffset,
            ulViewReload: crate::linked::ulViewReload,
            ulViewStop: crate::linked::ulViewStop,
            ulViewFocus: crate::linked::ulViewFocus,
            ulViewUnfocus: crate::linked::ulViewUnfocus,
            ulViewHasFocus: crate::linked::ulViewHasFocus,
            ulViewHasInputFocus: crate::linked::ulViewHasInputFocus,
            ulViewFireKeyEvent: crate::linked::ulViewFireKeyEvent,
            ulViewFireMouseEvent: crate::linked::ulViewFireMouseEvent,
            ulViewFireScrollEvent: crate::linked::ulViewFireScrollEvent,
            ulViewSetChangeTitleCallback: crate::linked::ulViewSetChangeTitleCallback,
            ulViewSetChangeURLCallback: crate::linked::ulViewSetChangeURLCallback,
            ulViewSetChangeTooltipCallback: crate::linked::ulViewSetChangeTooltipCallback,
            ulViewSetChangeCursorCallback: crate::linked::ulViewSetChangeCursorCallback,
            ulViewSetAddConsoleMessageCallback: crate::linked::ulViewSetAddConsoleMessageCallback,
            ulViewSetCreateChildViewCallback: crate::linked::ulViewSetCreateChildViewCallback,
            ulViewSetCreateInspectorViewCallback:
                crate::linked::ulViewSetCreateInspectorViewCallback,
            ulViewSetBeginLoadingCallback: crate::linked::ulViewSetBeginLoadingCallback,
            ulViewSetFinishLoadingCallback: crate::linked::ulViewSetFinishLoadingCallback,
            ulViewSetFailLoadingCallback: crate::linked::ulViewSetFailLoadingCallback,
            ulViewSetWindowObjectReadyCallback: crate::linked::ulViewSetWindowObjectReadyCallback,
            ulViewSetDOMReadyCallback: crate::linked::ulViewSetDOMReadyCallback,
            ulViewSetUpdateHistoryCallback: crate::linked::ulViewSetUpdateHistoryCallback,
            ulViewSetNeedsPaint: crate::linked::ulViewSetNeedsPaint,
            ulViewGetNeedsPaint: crate::linked::ulViewGetNeedsPaint,
            ulViewCreateLocalInspectorView: crate::linked::ulViewCreateLocalInspectorView,
        }
    }

    #[cfg(feature = "loaded")]
    #[cfg_attr(docsrs, doc(cfg(feature = "loaded")))]
    pub unsafe fn load_from<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }

    #[cfg(feature = "loaded")]
    #[cfg_attr(docsrs, doc(cfg(feature = "loaded")))]
    unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let JSEvaluateScript = __library.get(b"JSEvaluateScript\0").map(|sym| *sym)?;
        let JSCheckScriptSyntax = __library.get(b"JSCheckScriptSyntax\0").map(|sym| *sym)?;
        let JSGarbageCollect = __library.get(b"JSGarbageCollect\0").map(|sym| *sym)?;
        let JSValueGetType = __library.get(b"JSValueGetType\0").map(|sym| *sym)?;
        let JSValueIsUndefined = __library.get(b"JSValueIsUndefined\0").map(|sym| *sym)?;
        let JSValueIsNull = __library.get(b"JSValueIsNull\0").map(|sym| *sym)?;
        let JSValueIsBoolean = __library.get(b"JSValueIsBoolean\0").map(|sym| *sym)?;
        let JSValueIsNumber = __library.get(b"JSValueIsNumber\0").map(|sym| *sym)?;
        let JSValueIsString = __library.get(b"JSValueIsString\0").map(|sym| *sym)?;
        let JSValueIsSymbol = __library.get(b"JSValueIsSymbol\0").map(|sym| *sym)?;
        let JSValueIsObject = __library.get(b"JSValueIsObject\0").map(|sym| *sym)?;
        let JSValueIsObjectOfClass = __library.get(b"JSValueIsObjectOfClass\0").map(|sym| *sym)?;
        let JSValueIsArray = __library.get(b"JSValueIsArray\0").map(|sym| *sym)?;
        let JSValueIsDate = __library.get(b"JSValueIsDate\0").map(|sym| *sym)?;
        let JSValueGetTypedArrayType = __library
            .get(b"JSValueGetTypedArrayType\0")
            .map(|sym| *sym)?;
        let JSValueIsEqual = __library.get(b"JSValueIsEqual\0").map(|sym| *sym)?;
        let JSValueIsStrictEqual = __library.get(b"JSValueIsStrictEqual\0").map(|sym| *sym)?;
        let JSValueIsInstanceOfConstructor = __library
            .get(b"JSValueIsInstanceOfConstructor\0")
            .map(|sym| *sym)?;
        let JSValueMakeUndefined = __library.get(b"JSValueMakeUndefined\0").map(|sym| *sym)?;
        let JSValueMakeNull = __library.get(b"JSValueMakeNull\0").map(|sym| *sym)?;
        let JSValueMakeBoolean = __library.get(b"JSValueMakeBoolean\0").map(|sym| *sym)?;
        let JSValueMakeNumber = __library.get(b"JSValueMakeNumber\0").map(|sym| *sym)?;
        let JSValueMakeString = __library.get(b"JSValueMakeString\0").map(|sym| *sym)?;
        let JSValueMakeSymbol = __library.get(b"JSValueMakeSymbol\0").map(|sym| *sym)?;
        let JSValueMakeFromJSONString = __library
            .get(b"JSValueMakeFromJSONString\0")
            .map(|sym| *sym)?;
        let JSValueCreateJSONString = __library
            .get(b"JSValueCreateJSONString\0")
            .map(|sym| *sym)?;
        let JSValueToBoolean = __library.get(b"JSValueToBoolean\0").map(|sym| *sym)?;
        let JSValueToNumber = __library.get(b"JSValueToNumber\0").map(|sym| *sym)?;
        let JSValueToStringCopy = __library.get(b"JSValueToStringCopy\0").map(|sym| *sym)?;
        let JSValueToObject = __library.get(b"JSValueToObject\0").map(|sym| *sym)?;
        let JSValueProtect = __library.get(b"JSValueProtect\0").map(|sym| *sym)?;
        let JSValueUnprotect = __library.get(b"JSValueUnprotect\0").map(|sym| *sym)?;
        let JSClassCreate = __library.get(b"JSClassCreate\0").map(|sym| *sym)?;
        let JSClassRetain = __library.get(b"JSClassRetain\0").map(|sym| *sym)?;
        let JSClassRelease = __library.get(b"JSClassRelease\0").map(|sym| *sym)?;
        let JSObjectMake = __library.get(b"JSObjectMake\0").map(|sym| *sym)?;
        let JSObjectMakeFunctionWithCallback = __library
            .get(b"JSObjectMakeFunctionWithCallback\0")
            .map(|sym| *sym)?;
        let JSObjectMakeConstructor = __library
            .get(b"JSObjectMakeConstructor\0")
            .map(|sym| *sym)?;
        let JSObjectMakeArray = __library.get(b"JSObjectMakeArray\0").map(|sym| *sym)?;
        let JSObjectMakeDate = __library.get(b"JSObjectMakeDate\0").map(|sym| *sym)?;
        let JSObjectMakeError = __library.get(b"JSObjectMakeError\0").map(|sym| *sym)?;
        let JSObjectMakeRegExp = __library.get(b"JSObjectMakeRegExp\0").map(|sym| *sym)?;
        let JSObjectMakeDeferredPromise = __library
            .get(b"JSObjectMakeDeferredPromise\0")
            .map(|sym| *sym)?;
        let JSObjectMakeFunction = __library.get(b"JSObjectMakeFunction\0").map(|sym| *sym)?;
        let JSObjectGetPrototype = __library.get(b"JSObjectGetPrototype\0").map(|sym| *sym)?;
        let JSObjectSetPrototype = __library.get(b"JSObjectSetPrototype\0").map(|sym| *sym)?;
        let JSObjectHasProperty = __library.get(b"JSObjectHasProperty\0").map(|sym| *sym)?;
        let JSObjectGetProperty = __library.get(b"JSObjectGetProperty\0").map(|sym| *sym)?;
        let JSObjectSetProperty = __library.get(b"JSObjectSetProperty\0").map(|sym| *sym)?;
        let JSObjectDeleteProperty = __library.get(b"JSObjectDeleteProperty\0").map(|sym| *sym)?;
        let JSObjectHasPropertyForKey = __library
            .get(b"JSObjectHasPropertyForKey\0")
            .map(|sym| *sym)?;
        let JSObjectGetPropertyForKey = __library
            .get(b"JSObjectGetPropertyForKey\0")
            .map(|sym| *sym)?;
        let JSObjectSetPropertyForKey = __library
            .get(b"JSObjectSetPropertyForKey\0")
            .map(|sym| *sym)?;
        let JSObjectDeletePropertyForKey = __library
            .get(b"JSObjectDeletePropertyForKey\0")
            .map(|sym| *sym)?;
        let JSObjectGetPropertyAtIndex = __library
            .get(b"JSObjectGetPropertyAtIndex\0")
            .map(|sym| *sym)?;
        let JSObjectSetPropertyAtIndex = __library
            .get(b"JSObjectSetPropertyAtIndex\0")
            .map(|sym| *sym)?;
        let JSObjectGetPrivate = __library.get(b"JSObjectGetPrivate\0").map(|sym| *sym)?;
        let JSObjectSetPrivate = __library.get(b"JSObjectSetPrivate\0").map(|sym| *sym)?;
        let JSObjectIsFunction = __library.get(b"JSObjectIsFunction\0").map(|sym| *sym)?;
        let JSObjectCallAsFunction = __library.get(b"JSObjectCallAsFunction\0").map(|sym| *sym)?;
        let JSObjectIsConstructor = __library.get(b"JSObjectIsConstructor\0").map(|sym| *sym)?;
        let JSObjectCallAsConstructor = __library
            .get(b"JSObjectCallAsConstructor\0")
            .map(|sym| *sym)?;
        let JSObjectCopyPropertyNames = __library
            .get(b"JSObjectCopyPropertyNames\0")
            .map(|sym| *sym)?;
        let JSPropertyNameArrayRetain = __library
            .get(b"JSPropertyNameArrayRetain\0")
            .map(|sym| *sym)?;
        let JSPropertyNameArrayRelease = __library
            .get(b"JSPropertyNameArrayRelease\0")
            .map(|sym| *sym)?;
        let JSPropertyNameArrayGetCount = __library
            .get(b"JSPropertyNameArrayGetCount\0")
            .map(|sym| *sym)?;
        let JSPropertyNameArrayGetNameAtIndex = __library
            .get(b"JSPropertyNameArrayGetNameAtIndex\0")
            .map(|sym| *sym)?;
        let JSPropertyNameAccumulatorAddName = __library
            .get(b"JSPropertyNameAccumulatorAddName\0")
            .map(|sym| *sym)?;
        let JSContextGroupCreate = __library.get(b"JSContextGroupCreate\0").map(|sym| *sym)?;
        let JSContextGroupRetain = __library.get(b"JSContextGroupRetain\0").map(|sym| *sym)?;
        let JSContextGroupRelease = __library.get(b"JSContextGroupRelease\0").map(|sym| *sym)?;
        let JSGlobalContextCreate = __library.get(b"JSGlobalContextCreate\0").map(|sym| *sym)?;
        let JSGlobalContextCreateInGroup = __library
            .get(b"JSGlobalContextCreateInGroup\0")
            .map(|sym| *sym)?;
        let JSGlobalContextRetain = __library.get(b"JSGlobalContextRetain\0").map(|sym| *sym)?;
        let JSGlobalContextRelease = __library.get(b"JSGlobalContextRelease\0").map(|sym| *sym)?;
        let JSContextGetGlobalObject = __library
            .get(b"JSContextGetGlobalObject\0")
            .map(|sym| *sym)?;
        let JSContextGetGroup = __library.get(b"JSContextGetGroup\0").map(|sym| *sym)?;
        let JSContextGetGlobalContext = __library
            .get(b"JSContextGetGlobalContext\0")
            .map(|sym| *sym)?;
        let JSGlobalContextCopyName = __library
            .get(b"JSGlobalContextCopyName\0")
            .map(|sym| *sym)?;
        let JSGlobalContextSetName = __library.get(b"JSGlobalContextSetName\0").map(|sym| *sym)?;
        let JSGlobalContextIsInspectable = __library
            .get(b"JSGlobalContextIsInspectable\0")
            .map(|sym| *sym)?;
        let JSGlobalContextSetInspectable = __library
            .get(b"JSGlobalContextSetInspectable\0")
            .map(|sym| *sym)?;
        let JSStringCreateWithCharacters = __library
            .get(b"JSStringCreateWithCharacters\0")
            .map(|sym| *sym)?;
        let JSStringCreateWithUTF8CString = __library
            .get(b"JSStringCreateWithUTF8CString\0")
            .map(|sym| *sym)?;
        let JSStringRetain = __library.get(b"JSStringRetain\0").map(|sym| *sym)?;
        let JSStringRelease = __library.get(b"JSStringRelease\0").map(|sym| *sym)?;
        let JSStringGetLength = __library.get(b"JSStringGetLength\0").map(|sym| *sym)?;
        let JSStringGetCharactersPtr = __library
            .get(b"JSStringGetCharactersPtr\0")
            .map(|sym| *sym)?;
        let JSStringGetMaximumUTF8CStringSize = __library
            .get(b"JSStringGetMaximumUTF8CStringSize\0")
            .map(|sym| *sym)?;
        let JSStringGetUTF8CString = __library.get(b"JSStringGetUTF8CString\0").map(|sym| *sym)?;
        let JSStringIsEqual = __library.get(b"JSStringIsEqual\0").map(|sym| *sym)?;
        let JSStringIsEqualToUTF8CString = __library
            .get(b"JSStringIsEqualToUTF8CString\0")
            .map(|sym| *sym)?;
        let JSObjectMakeTypedArray = __library.get(b"JSObjectMakeTypedArray\0").map(|sym| *sym)?;
        let JSObjectMakeTypedArrayWithBytesNoCopy = __library
            .get(b"JSObjectMakeTypedArrayWithBytesNoCopy\0")
            .map(|sym| *sym)?;
        let JSObjectMakeTypedArrayWithArrayBuffer = __library
            .get(b"JSObjectMakeTypedArrayWithArrayBuffer\0")
            .map(|sym| *sym)?;
        let JSObjectMakeTypedArrayWithArrayBufferAndOffset = __library
            .get(b"JSObjectMakeTypedArrayWithArrayBufferAndOffset\0")
            .map(|sym| *sym)?;
        let JSObjectGetTypedArrayBytesPtr = __library
            .get(b"JSObjectGetTypedArrayBytesPtr\0")
            .map(|sym| *sym)?;
        let JSObjectGetTypedArrayLength = __library
            .get(b"JSObjectGetTypedArrayLength\0")
            .map(|sym| *sym)?;
        let JSObjectGetTypedArrayByteLength = __library
            .get(b"JSObjectGetTypedArrayByteLength\0")
            .map(|sym| *sym)?;
        let JSObjectGetTypedArrayByteOffset = __library
            .get(b"JSObjectGetTypedArrayByteOffset\0")
            .map(|sym| *sym)?;
        let JSObjectGetTypedArrayBuffer = __library
            .get(b"JSObjectGetTypedArrayBuffer\0")
            .map(|sym| *sym)?;
        let JSObjectMakeArrayBufferWithBytesNoCopy = __library
            .get(b"JSObjectMakeArrayBufferWithBytesNoCopy\0")
            .map(|sym| *sym)?;
        let JSObjectGetArrayBufferBytesPtr = __library
            .get(b"JSObjectGetArrayBufferBytesPtr\0")
            .map(|sym| *sym)?;
        let JSObjectGetArrayBufferByteLength = __library
            .get(b"JSObjectGetArrayBufferByteLength\0")
            .map(|sym| *sym)?;
        let ulVersionString = __library.get(b"ulVersionString\0").map(|sym| *sym)?;
        let ulVersionMajor = __library.get(b"ulVersionMajor\0").map(|sym| *sym)?;
        let ulVersionMinor = __library.get(b"ulVersionMinor\0").map(|sym| *sym)?;
        let ulVersionPatch = __library.get(b"ulVersionPatch\0").map(|sym| *sym)?;
        let ulWebKitVersionString = __library.get(b"ulWebKitVersionString\0").map(|sym| *sym)?;
        let ulCreateEmptyBitmap = __library.get(b"ulCreateEmptyBitmap\0").map(|sym| *sym)?;
        let ulCreateBitmap = __library.get(b"ulCreateBitmap\0").map(|sym| *sym)?;
        let ulCreateBitmapFromPixels = __library
            .get(b"ulCreateBitmapFromPixels\0")
            .map(|sym| *sym)?;
        let ulCreateBitmapFromCopy = __library.get(b"ulCreateBitmapFromCopy\0").map(|sym| *sym)?;
        let ulDestroyBitmap = __library.get(b"ulDestroyBitmap\0").map(|sym| *sym)?;
        let ulBitmapGetWidth = __library.get(b"ulBitmapGetWidth\0").map(|sym| *sym)?;
        let ulBitmapGetHeight = __library.get(b"ulBitmapGetHeight\0").map(|sym| *sym)?;
        let ulBitmapGetFormat = __library.get(b"ulBitmapGetFormat\0").map(|sym| *sym)?;
        let ulBitmapGetBpp = __library.get(b"ulBitmapGetBpp\0").map(|sym| *sym)?;
        let ulBitmapGetRowBytes = __library.get(b"ulBitmapGetRowBytes\0").map(|sym| *sym)?;
        let ulBitmapGetSize = __library.get(b"ulBitmapGetSize\0").map(|sym| *sym)?;
        let ulBitmapOwnsPixels = __library.get(b"ulBitmapOwnsPixels\0").map(|sym| *sym)?;
        let ulBitmapLockPixels = __library.get(b"ulBitmapLockPixels\0").map(|sym| *sym)?;
        let ulBitmapUnlockPixels = __library.get(b"ulBitmapUnlockPixels\0").map(|sym| *sym)?;
        let ulBitmapRawPixels = __library.get(b"ulBitmapRawPixels\0").map(|sym| *sym)?;
        let ulBitmapIsEmpty = __library.get(b"ulBitmapIsEmpty\0").map(|sym| *sym)?;
        let ulBitmapErase = __library.get(b"ulBitmapErase\0").map(|sym| *sym)?;
        let ulBitmapWritePNG = __library.get(b"ulBitmapWritePNG\0").map(|sym| *sym)?;
        let ulBitmapSwapRedBlueChannels = __library
            .get(b"ulBitmapSwapRedBlueChannels\0")
            .map(|sym| *sym)?;
        let ulCreateBuffer = __library.get(b"ulCreateBuffer\0").map(|sym| *sym)?;
        let ulCreateBufferFromCopy = __library.get(b"ulCreateBufferFromCopy\0").map(|sym| *sym)?;
        let ulDestroyBuffer = __library.get(b"ulDestroyBuffer\0").map(|sym| *sym)?;
        let ulBufferGetData = __library.get(b"ulBufferGetData\0").map(|sym| *sym)?;
        let ulBufferGetSize = __library.get(b"ulBufferGetSize\0").map(|sym| *sym)?;
        let ulBufferGetUserData = __library.get(b"ulBufferGetUserData\0").map(|sym| *sym)?;
        let ulBufferOwnsData = __library.get(b"ulBufferOwnsData\0").map(|sym| *sym)?;
        let ulCreateConfig = __library.get(b"ulCreateConfig\0").map(|sym| *sym)?;
        let ulDestroyConfig = __library.get(b"ulDestroyConfig\0").map(|sym| *sym)?;
        let ulConfigSetCachePath = __library.get(b"ulConfigSetCachePath\0").map(|sym| *sym)?;
        let ulConfigSetResourcePathPrefix = __library
            .get(b"ulConfigSetResourcePathPrefix\0")
            .map(|sym| *sym)?;
        let ulConfigSetFaceWinding = __library.get(b"ulConfigSetFaceWinding\0").map(|sym| *sym)?;
        let ulConfigSetFontHinting = __library.get(b"ulConfigSetFontHinting\0").map(|sym| *sym)?;
        let ulConfigSetFontGamma = __library.get(b"ulConfigSetFontGamma\0").map(|sym| *sym)?;
        let ulConfigSetUserStylesheet = __library
            .get(b"ulConfigSetUserStylesheet\0")
            .map(|sym| *sym)?;
        let ulConfigSetForceRepaint = __library
            .get(b"ulConfigSetForceRepaint\0")
            .map(|sym| *sym)?;
        let ulConfigSetAnimationTimerDelay = __library
            .get(b"ulConfigSetAnimationTimerDelay\0")
            .map(|sym| *sym)?;
        let ulConfigSetScrollTimerDelay = __library
            .get(b"ulConfigSetScrollTimerDelay\0")
            .map(|sym| *sym)?;
        let ulConfigSetRecycleDelay = __library
            .get(b"ulConfigSetRecycleDelay\0")
            .map(|sym| *sym)?;
        let ulConfigSetMemoryCacheSize = __library
            .get(b"ulConfigSetMemoryCacheSize\0")
            .map(|sym| *sym)?;
        let ulConfigSetPageCacheSize = __library
            .get(b"ulConfigSetPageCacheSize\0")
            .map(|sym| *sym)?;
        let ulConfigSetOverrideRAMSize = __library
            .get(b"ulConfigSetOverrideRAMSize\0")
            .map(|sym| *sym)?;
        let ulConfigSetMinLargeHeapSize = __library
            .get(b"ulConfigSetMinLargeHeapSize\0")
            .map(|sym| *sym)?;
        let ulConfigSetMinSmallHeapSize = __library
            .get(b"ulConfigSetMinSmallHeapSize\0")
            .map(|sym| *sym)?;
        let ulConfigSetNumRendererThreads = __library
            .get(b"ulConfigSetNumRendererThreads\0")
            .map(|sym| *sym)?;
        let ulConfigSetMaxUpdateTime = __library
            .get(b"ulConfigSetMaxUpdateTime\0")
            .map(|sym| *sym)?;
        let ulConfigSetBitmapAlignment = __library
            .get(b"ulConfigSetBitmapAlignment\0")
            .map(|sym| *sym)?;
        let ulCreateString = __library.get(b"ulCreateString\0").map(|sym| *sym)?;
        let ulCreateStringUTF8 = __library.get(b"ulCreateStringUTF8\0").map(|sym| *sym)?;
        let ulCreateStringUTF16 = __library.get(b"ulCreateStringUTF16\0").map(|sym| *sym)?;
        let ulCreateStringFromCopy = __library.get(b"ulCreateStringFromCopy\0").map(|sym| *sym)?;
        let ulDestroyString = __library.get(b"ulDestroyString\0").map(|sym| *sym)?;
        let ulStringGetData = __library.get(b"ulStringGetData\0").map(|sym| *sym)?;
        let ulStringGetLength = __library.get(b"ulStringGetLength\0").map(|sym| *sym)?;
        let ulStringIsEmpty = __library.get(b"ulStringIsEmpty\0").map(|sym| *sym)?;
        let ulStringAssignString = __library.get(b"ulStringAssignString\0").map(|sym| *sym)?;
        let ulStringAssignCString = __library.get(b"ulStringAssignCString\0").map(|sym| *sym)?;
        let ulFontFileCreateFromFilePath = __library
            .get(b"ulFontFileCreateFromFilePath\0")
            .map(|sym| *sym)?;
        let ulFontFileCreateFromBuffer = __library
            .get(b"ulFontFileCreateFromBuffer\0")
            .map(|sym| *sym)?;
        let ulDestroyFontFile = __library.get(b"ulDestroyFontFile\0").map(|sym| *sym)?;
        let ulRectIsEmpty = __library.get(b"ulRectIsEmpty\0").map(|sym| *sym)?;
        let ulRectMakeEmpty = __library.get(b"ulRectMakeEmpty\0").map(|sym| *sym)?;
        let ulIntRectIsEmpty = __library.get(b"ulIntRectIsEmpty\0").map(|sym| *sym)?;
        let ulIntRectMakeEmpty = __library.get(b"ulIntRectMakeEmpty\0").map(|sym| *sym)?;
        let ulApplyProjection = __library.get(b"ulApplyProjection\0").map(|sym| *sym)?;
        let ulCreateImageSourceFromTexture = __library
            .get(b"ulCreateImageSourceFromTexture\0")
            .map(|sym| *sym)?;
        let ulCreateImageSourceFromBitmap = __library
            .get(b"ulCreateImageSourceFromBitmap\0")
            .map(|sym| *sym)?;
        let ulDestroyImageSource = __library.get(b"ulDestroyImageSource\0").map(|sym| *sym)?;
        let ulImageSourceInvalidate = __library
            .get(b"ulImageSourceInvalidate\0")
            .map(|sym| *sym)?;
        let ulImageSourceProviderAddImageSource = __library
            .get(b"ulImageSourceProviderAddImageSource\0")
            .map(|sym| *sym)?;
        let ulImageSourceProviderRemoveImageSource = __library
            .get(b"ulImageSourceProviderRemoveImageSource\0")
            .map(|sym| *sym)?;
        let ulCreateKeyEvent = __library.get(b"ulCreateKeyEvent\0").map(|sym| *sym)?;
        let ulDestroyKeyEvent = __library.get(b"ulDestroyKeyEvent\0").map(|sym| *sym)?;
        let ulCreateMouseEvent = __library.get(b"ulCreateMouseEvent\0").map(|sym| *sym)?;
        let ulDestroyMouseEvent = __library.get(b"ulDestroyMouseEvent\0").map(|sym| *sym)?;
        let ulSurfaceGetWidth = __library.get(b"ulSurfaceGetWidth\0").map(|sym| *sym)?;
        let ulSurfaceGetHeight = __library.get(b"ulSurfaceGetHeight\0").map(|sym| *sym)?;
        let ulSurfaceGetRowBytes = __library.get(b"ulSurfaceGetRowBytes\0").map(|sym| *sym)?;
        let ulSurfaceGetSize = __library.get(b"ulSurfaceGetSize\0").map(|sym| *sym)?;
        let ulSurfaceLockPixels = __library.get(b"ulSurfaceLockPixels\0").map(|sym| *sym)?;
        let ulSurfaceUnlockPixels = __library.get(b"ulSurfaceUnlockPixels\0").map(|sym| *sym)?;
        let ulSurfaceResize = __library.get(b"ulSurfaceResize\0").map(|sym| *sym)?;
        let ulSurfaceSetDirtyBounds = __library
            .get(b"ulSurfaceSetDirtyBounds\0")
            .map(|sym| *sym)?;
        let ulSurfaceGetDirtyBounds = __library
            .get(b"ulSurfaceGetDirtyBounds\0")
            .map(|sym| *sym)?;
        let ulSurfaceClearDirtyBounds = __library
            .get(b"ulSurfaceClearDirtyBounds\0")
            .map(|sym| *sym)?;
        let ulSurfaceGetUserData = __library.get(b"ulSurfaceGetUserData\0").map(|sym| *sym)?;
        let ulBitmapSurfaceGetBitmap = __library
            .get(b"ulBitmapSurfaceGetBitmap\0")
            .map(|sym| *sym)?;
        let ulPlatformSetLogger = __library.get(b"ulPlatformSetLogger\0").map(|sym| *sym)?;
        let ulPlatformSetFileSystem = __library
            .get(b"ulPlatformSetFileSystem\0")
            .map(|sym| *sym)?;
        let ulPlatformSetSurfaceDefinition = __library
            .get(b"ulPlatformSetSurfaceDefinition\0")
            .map(|sym| *sym)?;
        let ulPlatformSetGPUDriver = __library.get(b"ulPlatformSetGPUDriver\0").map(|sym| *sym)?;
        let ulPlatformSetClipboard = __library.get(b"ulPlatformSetClipboard\0").map(|sym| *sym)?;
        let ulCreateRenderer = __library.get(b"ulCreateRenderer\0").map(|sym| *sym)?;
        let ulDestroyRenderer = __library.get(b"ulDestroyRenderer\0").map(|sym| *sym)?;
        let ulUpdate = __library.get(b"ulUpdate\0").map(|sym| *sym)?;
        let ulRefreshDisplay = __library.get(b"ulRefreshDisplay\0").map(|sym| *sym)?;
        let ulRender = __library.get(b"ulRender\0").map(|sym| *sym)?;
        let ulPurgeMemory = __library.get(b"ulPurgeMemory\0").map(|sym| *sym)?;
        let ulLogMemoryUsage = __library.get(b"ulLogMemoryUsage\0").map(|sym| *sym)?;
        let ulStartRemoteInspectorServer = __library
            .get(b"ulStartRemoteInspectorServer\0")
            .map(|sym| *sym)?;
        let ulSetGamepadDetails = __library.get(b"ulSetGamepadDetails\0").map(|sym| *sym)?;
        let ulFireGamepadEvent = __library.get(b"ulFireGamepadEvent\0").map(|sym| *sym)?;
        let ulFireGamepadAxisEvent = __library.get(b"ulFireGamepadAxisEvent\0").map(|sym| *sym)?;
        let ulFireGamepadButtonEvent = __library
            .get(b"ulFireGamepadButtonEvent\0")
            .map(|sym| *sym)?;
        let ulCreateScrollEvent = __library.get(b"ulCreateScrollEvent\0").map(|sym| *sym)?;
        let ulDestroyScrollEvent = __library.get(b"ulDestroyScrollEvent\0").map(|sym| *sym)?;
        let ulCreateGamepadEvent = __library.get(b"ulCreateGamepadEvent\0").map(|sym| *sym)?;
        let ulDestroyGamepadEvent = __library.get(b"ulDestroyGamepadEvent\0").map(|sym| *sym)?;
        let ulCreateGamepadAxisEvent = __library
            .get(b"ulCreateGamepadAxisEvent\0")
            .map(|sym| *sym)?;
        let ulDestroyGamepadAxisEvent = __library
            .get(b"ulDestroyGamepadAxisEvent\0")
            .map(|sym| *sym)?;
        let ulCreateGamepadButtonEvent = __library
            .get(b"ulCreateGamepadButtonEvent\0")
            .map(|sym| *sym)?;
        let ulDestroyGamepadButtonEvent = __library
            .get(b"ulDestroyGamepadButtonEvent\0")
            .map(|sym| *sym)?;
        let ulCreateSession = __library.get(b"ulCreateSession\0").map(|sym| *sym)?;
        let ulDestroySession = __library.get(b"ulDestroySession\0").map(|sym| *sym)?;
        let ulDefaultSession = __library.get(b"ulDefaultSession\0").map(|sym| *sym)?;
        let ulSessionIsPersistent = __library.get(b"ulSessionIsPersistent\0").map(|sym| *sym)?;
        let ulSessionGetName = __library.get(b"ulSessionGetName\0").map(|sym| *sym)?;
        let ulSessionGetId = __library.get(b"ulSessionGetId\0").map(|sym| *sym)?;
        let ulSessionGetDiskPath = __library.get(b"ulSessionGetDiskPath\0").map(|sym| *sym)?;
        let ulCreateViewConfig = __library.get(b"ulCreateViewConfig\0").map(|sym| *sym)?;
        let ulDestroyViewConfig = __library.get(b"ulDestroyViewConfig\0").map(|sym| *sym)?;
        let ulViewConfigSetDisplayId = __library
            .get(b"ulViewConfigSetDisplayId\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetIsAccelerated = __library
            .get(b"ulViewConfigSetIsAccelerated\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetIsTransparent = __library
            .get(b"ulViewConfigSetIsTransparent\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetInitialDeviceScale = __library
            .get(b"ulViewConfigSetInitialDeviceScale\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetInitialFocus = __library
            .get(b"ulViewConfigSetInitialFocus\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetEnableImages = __library
            .get(b"ulViewConfigSetEnableImages\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetEnableJavaScript = __library
            .get(b"ulViewConfigSetEnableJavaScript\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetFontFamilyStandard = __library
            .get(b"ulViewConfigSetFontFamilyStandard\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetFontFamilyFixed = __library
            .get(b"ulViewConfigSetFontFamilyFixed\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetFontFamilySerif = __library
            .get(b"ulViewConfigSetFontFamilySerif\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetFontFamilySansSerif = __library
            .get(b"ulViewConfigSetFontFamilySansSerif\0")
            .map(|sym| *sym)?;
        let ulViewConfigSetUserAgent = __library
            .get(b"ulViewConfigSetUserAgent\0")
            .map(|sym| *sym)?;
        let ulCreateView = __library.get(b"ulCreateView\0").map(|sym| *sym)?;
        let ulDestroyView = __library.get(b"ulDestroyView\0").map(|sym| *sym)?;
        let ulViewGetURL = __library.get(b"ulViewGetURL\0").map(|sym| *sym)?;
        let ulViewGetTitle = __library.get(b"ulViewGetTitle\0").map(|sym| *sym)?;
        let ulViewGetWidth = __library.get(b"ulViewGetWidth\0").map(|sym| *sym)?;
        let ulViewGetHeight = __library.get(b"ulViewGetHeight\0").map(|sym| *sym)?;
        let ulViewGetDisplayId = __library.get(b"ulViewGetDisplayId\0").map(|sym| *sym)?;
        let ulViewSetDisplayId = __library.get(b"ulViewSetDisplayId\0").map(|sym| *sym)?;
        let ulViewGetDeviceScale = __library.get(b"ulViewGetDeviceScale\0").map(|sym| *sym)?;
        let ulViewSetDeviceScale = __library.get(b"ulViewSetDeviceScale\0").map(|sym| *sym)?;
        let ulViewIsAccelerated = __library.get(b"ulViewIsAccelerated\0").map(|sym| *sym)?;
        let ulViewIsTransparent = __library.get(b"ulViewIsTransparent\0").map(|sym| *sym)?;
        let ulViewIsLoading = __library.get(b"ulViewIsLoading\0").map(|sym| *sym)?;
        let ulViewGetRenderTarget = __library.get(b"ulViewGetRenderTarget\0").map(|sym| *sym)?;
        let ulViewGetSurface = __library.get(b"ulViewGetSurface\0").map(|sym| *sym)?;
        let ulViewLoadHTML = __library.get(b"ulViewLoadHTML\0").map(|sym| *sym)?;
        let ulViewLoadURL = __library.get(b"ulViewLoadURL\0").map(|sym| *sym)?;
        let ulViewResize = __library.get(b"ulViewResize\0").map(|sym| *sym)?;
        let ulViewLockJSContext = __library.get(b"ulViewLockJSContext\0").map(|sym| *sym)?;
        let ulViewUnlockJSContext = __library.get(b"ulViewUnlockJSContext\0").map(|sym| *sym)?;
        let ulViewEvaluateScript = __library.get(b"ulViewEvaluateScript\0").map(|sym| *sym)?;
        let ulViewCanGoBack = __library.get(b"ulViewCanGoBack\0").map(|sym| *sym)?;
        let ulViewCanGoForward = __library.get(b"ulViewCanGoForward\0").map(|sym| *sym)?;
        let ulViewGoBack = __library.get(b"ulViewGoBack\0").map(|sym| *sym)?;
        let ulViewGoForward = __library.get(b"ulViewGoForward\0").map(|sym| *sym)?;
        let ulViewGoToHistoryOffset = __library
            .get(b"ulViewGoToHistoryOffset\0")
            .map(|sym| *sym)?;
        let ulViewReload = __library.get(b"ulViewReload\0").map(|sym| *sym)?;
        let ulViewStop = __library.get(b"ulViewStop\0").map(|sym| *sym)?;
        let ulViewFocus = __library.get(b"ulViewFocus\0").map(|sym| *sym)?;
        let ulViewUnfocus = __library.get(b"ulViewUnfocus\0").map(|sym| *sym)?;
        let ulViewHasFocus = __library.get(b"ulViewHasFocus\0").map(|sym| *sym)?;
        let ulViewHasInputFocus = __library.get(b"ulViewHasInputFocus\0").map(|sym| *sym)?;
        let ulViewFireKeyEvent = __library.get(b"ulViewFireKeyEvent\0").map(|sym| *sym)?;
        let ulViewFireMouseEvent = __library.get(b"ulViewFireMouseEvent\0").map(|sym| *sym)?;
        let ulViewFireScrollEvent = __library.get(b"ulViewFireScrollEvent\0").map(|sym| *sym)?;
        let ulViewSetChangeTitleCallback = __library
            .get(b"ulViewSetChangeTitleCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetChangeURLCallback = __library
            .get(b"ulViewSetChangeURLCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetChangeTooltipCallback = __library
            .get(b"ulViewSetChangeTooltipCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetChangeCursorCallback = __library
            .get(b"ulViewSetChangeCursorCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetAddConsoleMessageCallback = __library
            .get(b"ulViewSetAddConsoleMessageCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetCreateChildViewCallback = __library
            .get(b"ulViewSetCreateChildViewCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetCreateInspectorViewCallback = __library
            .get(b"ulViewSetCreateInspectorViewCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetBeginLoadingCallback = __library
            .get(b"ulViewSetBeginLoadingCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetFinishLoadingCallback = __library
            .get(b"ulViewSetFinishLoadingCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetFailLoadingCallback = __library
            .get(b"ulViewSetFailLoadingCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetWindowObjectReadyCallback = __library
            .get(b"ulViewSetWindowObjectReadyCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetDOMReadyCallback = __library
            .get(b"ulViewSetDOMReadyCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetUpdateHistoryCallback = __library
            .get(b"ulViewSetUpdateHistoryCallback\0")
            .map(|sym| *sym)?;
        let ulViewSetNeedsPaint = __library.get(b"ulViewSetNeedsPaint\0").map(|sym| *sym)?;
        let ulViewGetNeedsPaint = __library.get(b"ulViewGetNeedsPaint\0").map(|sym| *sym)?;
        let ulViewCreateLocalInspectorView = __library
            .get(b"ulViewCreateLocalInspectorView\0")
            .map(|sym| *sym)?;
        Ok(Ultralight {
            __library: Some(::std::sync::Arc::new(__library)),
            JSEvaluateScript,
            JSCheckScriptSyntax,
            JSGarbageCollect,
            JSValueGetType,
            JSValueIsUndefined,
            JSValueIsNull,
            JSValueIsBoolean,
            JSValueIsNumber,
            JSValueIsString,
            JSValueIsSymbol,
            JSValueIsObject,
            JSValueIsObjectOfClass,
            JSValueIsArray,
            JSValueIsDate,
            JSValueGetTypedArrayType,
            JSValueIsEqual,
            JSValueIsStrictEqual,
            JSValueIsInstanceOfConstructor,
            JSValueMakeUndefined,
            JSValueMakeNull,
            JSValueMakeBoolean,
            JSValueMakeNumber,
            JSValueMakeString,
            JSValueMakeSymbol,
            JSValueMakeFromJSONString,
            JSValueCreateJSONString,
            JSValueToBoolean,
            JSValueToNumber,
            JSValueToStringCopy,
            JSValueToObject,
            JSValueProtect,
            JSValueUnprotect,
            JSClassCreate,
            JSClassRetain,
            JSClassRelease,
            JSObjectMake,
            JSObjectMakeFunctionWithCallback,
            JSObjectMakeConstructor,
            JSObjectMakeArray,
            JSObjectMakeDate,
            JSObjectMakeError,
            JSObjectMakeRegExp,
            JSObjectMakeDeferredPromise,
            JSObjectMakeFunction,
            JSObjectGetPrototype,
            JSObjectSetPrototype,
            JSObjectHasProperty,
            JSObjectGetProperty,
            JSObjectSetProperty,
            JSObjectDeleteProperty,
            JSObjectHasPropertyForKey,
            JSObjectGetPropertyForKey,
            JSObjectSetPropertyForKey,
            JSObjectDeletePropertyForKey,
            JSObjectGetPropertyAtIndex,
            JSObjectSetPropertyAtIndex,
            JSObjectGetPrivate,
            JSObjectSetPrivate,
            JSObjectIsFunction,
            JSObjectCallAsFunction,
            JSObjectIsConstructor,
            JSObjectCallAsConstructor,
            JSObjectCopyPropertyNames,
            JSPropertyNameArrayRetain,
            JSPropertyNameArrayRelease,
            JSPropertyNameArrayGetCount,
            JSPropertyNameArrayGetNameAtIndex,
            JSPropertyNameAccumulatorAddName,
            JSContextGroupCreate,
            JSContextGroupRetain,
            JSContextGroupRelease,
            JSGlobalContextCreate,
            JSGlobalContextCreateInGroup,
            JSGlobalContextRetain,
            JSGlobalContextRelease,
            JSContextGetGlobalObject,
            JSContextGetGroup,
            JSContextGetGlobalContext,
            JSGlobalContextCopyName,
            JSGlobalContextSetName,
            JSGlobalContextIsInspectable,
            JSGlobalContextSetInspectable,
            JSStringCreateWithCharacters,
            JSStringCreateWithUTF8CString,
            JSStringRetain,
            JSStringRelease,
            JSStringGetLength,
            JSStringGetCharactersPtr,
            JSStringGetMaximumUTF8CStringSize,
            JSStringGetUTF8CString,
            JSStringIsEqual,
            JSStringIsEqualToUTF8CString,
            JSObjectMakeTypedArray,
            JSObjectMakeTypedArrayWithBytesNoCopy,
            JSObjectMakeTypedArrayWithArrayBuffer,
            JSObjectMakeTypedArrayWithArrayBufferAndOffset,
            JSObjectGetTypedArrayBytesPtr,
            JSObjectGetTypedArrayLength,
            JSObjectGetTypedArrayByteLength,
            JSObjectGetTypedArrayByteOffset,
            JSObjectGetTypedArrayBuffer,
            JSObjectMakeArrayBufferWithBytesNoCopy,
            JSObjectGetArrayBufferBytesPtr,
            JSObjectGetArrayBufferByteLength,
            ulVersionString,
            ulVersionMajor,
            ulVersionMinor,
            ulVersionPatch,
            ulWebKitVersionString,
            ulCreateEmptyBitmap,
            ulCreateBitmap,
            ulCreateBitmapFromPixels,
            ulCreateBitmapFromCopy,
            ulDestroyBitmap,
            ulBitmapGetWidth,
            ulBitmapGetHeight,
            ulBitmapGetFormat,
            ulBitmapGetBpp,
            ulBitmapGetRowBytes,
            ulBitmapGetSize,
            ulBitmapOwnsPixels,
            ulBitmapLockPixels,
            ulBitmapUnlockPixels,
            ulBitmapRawPixels,
            ulBitmapIsEmpty,
            ulBitmapErase,
            ulBitmapWritePNG,
            ulBitmapSwapRedBlueChannels,
            ulCreateBuffer,
            ulCreateBufferFromCopy,
            ulDestroyBuffer,
            ulBufferGetData,
            ulBufferGetSize,
            ulBufferGetUserData,
            ulBufferOwnsData,
            ulCreateConfig,
            ulDestroyConfig,
            ulConfigSetCachePath,
            ulConfigSetResourcePathPrefix,
            ulConfigSetFaceWinding,
            ulConfigSetFontHinting,
            ulConfigSetFontGamma,
            ulConfigSetUserStylesheet,
            ulConfigSetForceRepaint,
            ulConfigSetAnimationTimerDelay,
            ulConfigSetScrollTimerDelay,
            ulConfigSetRecycleDelay,
            ulConfigSetMemoryCacheSize,
            ulConfigSetPageCacheSize,
            ulConfigSetOverrideRAMSize,
            ulConfigSetMinLargeHeapSize,
            ulConfigSetMinSmallHeapSize,
            ulConfigSetNumRendererThreads,
            ulConfigSetMaxUpdateTime,
            ulConfigSetBitmapAlignment,
            ulCreateString,
            ulCreateStringUTF8,
            ulCreateStringUTF16,
            ulCreateStringFromCopy,
            ulDestroyString,
            ulStringGetData,
            ulStringGetLength,
            ulStringIsEmpty,
            ulStringAssignString,
            ulStringAssignCString,
            ulFontFileCreateFromFilePath,
            ulFontFileCreateFromBuffer,
            ulDestroyFontFile,
            ulRectIsEmpty,
            ulRectMakeEmpty,
            ulIntRectIsEmpty,
            ulIntRectMakeEmpty,
            ulApplyProjection,
            ulCreateImageSourceFromTexture,
            ulCreateImageSourceFromBitmap,
            ulDestroyImageSource,
            ulImageSourceInvalidate,
            ulImageSourceProviderAddImageSource,
            ulImageSourceProviderRemoveImageSource,
            ulCreateKeyEvent,
            ulDestroyKeyEvent,
            ulCreateMouseEvent,
            ulDestroyMouseEvent,
            ulSurfaceGetWidth,
            ulSurfaceGetHeight,
            ulSurfaceGetRowBytes,
            ulSurfaceGetSize,
            ulSurfaceLockPixels,
            ulSurfaceUnlockPixels,
            ulSurfaceResize,
            ulSurfaceSetDirtyBounds,
            ulSurfaceGetDirtyBounds,
            ulSurfaceClearDirtyBounds,
            ulSurfaceGetUserData,
            ulBitmapSurfaceGetBitmap,
            ulPlatformSetLogger,
            ulPlatformSetFileSystem,
            ulPlatformSetSurfaceDefinition,
            ulPlatformSetGPUDriver,
            ulPlatformSetClipboard,
            ulCreateRenderer,
            ulDestroyRenderer,
            ulUpdate,
            ulRefreshDisplay,
            ulRender,
            ulPurgeMemory,
            ulLogMemoryUsage,
            ulStartRemoteInspectorServer,
            ulSetGamepadDetails,
            ulFireGamepadEvent,
            ulFireGamepadAxisEvent,
            ulFireGamepadButtonEvent,
            ulCreateScrollEvent,
            ulDestroyScrollEvent,
            ulCreateGamepadEvent,
            ulDestroyGamepadEvent,
            ulCreateGamepadAxisEvent,
            ulDestroyGamepadAxisEvent,
            ulCreateGamepadButtonEvent,
            ulDestroyGamepadButtonEvent,
            ulCreateSession,
            ulDestroySession,
            ulDefaultSession,
            ulSessionIsPersistent,
            ulSessionGetName,
            ulSessionGetId,
            ulSessionGetDiskPath,
            ulCreateViewConfig,
            ulDestroyViewConfig,
            ulViewConfigSetDisplayId,
            ulViewConfigSetIsAccelerated,
            ulViewConfigSetIsTransparent,
            ulViewConfigSetInitialDeviceScale,
            ulViewConfigSetInitialFocus,
            ulViewConfigSetEnableImages,
            ulViewConfigSetEnableJavaScript,
            ulViewConfigSetFontFamilyStandard,
            ulViewConfigSetFontFamilyFixed,
            ulViewConfigSetFontFamilySerif,
            ulViewConfigSetFontFamilySansSerif,
            ulViewConfigSetUserAgent,
            ulCreateView,
            ulDestroyView,
            ulViewGetURL,
            ulViewGetTitle,
            ulViewGetWidth,
            ulViewGetHeight,
            ulViewGetDisplayId,
            ulViewSetDisplayId,
            ulViewGetDeviceScale,
            ulViewSetDeviceScale,
            ulViewIsAccelerated,
            ulViewIsTransparent,
            ulViewIsLoading,
            ulViewGetRenderTarget,
            ulViewGetSurface,
            ulViewLoadHTML,
            ulViewLoadURL,
            ulViewResize,
            ulViewLockJSContext,
            ulViewUnlockJSContext,
            ulViewEvaluateScript,
            ulViewCanGoBack,
            ulViewCanGoForward,
            ulViewGoBack,
            ulViewGoForward,
            ulViewGoToHistoryOffset,
            ulViewReload,
            ulViewStop,
            ulViewFocus,
            ulViewUnfocus,
            ulViewHasFocus,
            ulViewHasInputFocus,
            ulViewFireKeyEvent,
            ulViewFireMouseEvent,
            ulViewFireScrollEvent,
            ulViewSetChangeTitleCallback,
            ulViewSetChangeURLCallback,
            ulViewSetChangeTooltipCallback,
            ulViewSetChangeCursorCallback,
            ulViewSetAddConsoleMessageCallback,
            ulViewSetCreateChildViewCallback,
            ulViewSetCreateInspectorViewCallback,
            ulViewSetBeginLoadingCallback,
            ulViewSetFinishLoadingCallback,
            ulViewSetFailLoadingCallback,
            ulViewSetWindowObjectReadyCallback,
            ulViewSetDOMReadyCallback,
            ulViewSetUpdateHistoryCallback,
            ulViewSetNeedsPaint,
            ulViewGetNeedsPaint,
            ulViewCreateLocalInspectorView,
        })
    }
    #[doc = "@function JSEvaluateScript\n@abstract Evaluates a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to evaluate.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param sourceURL A JSString containing a URL for the script's source file. This is used by debuggers and when reporting exceptions. Pass NULL if you do not care to include source file information.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from evaluating script, or NULL if an exception is thrown."]
    pub unsafe fn JSEvaluateScript(
        &self,
        ctx: JSContextRef,
        script: JSStringRef,
        thisObject: JSObjectRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSValueRef {
        (self.JSEvaluateScript)(
            ctx,
            script,
            thisObject,
            sourceURL,
            startingLineNumber,
            exception,
        )
    }
    #[doc = "@function JSCheckScriptSyntax\n@abstract Checks for syntax errors in a string of JavaScript.\n@param ctx The execution context to use.\n@param script A JSString containing the script to check for syntax errors.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result true if the script is syntactically correct, otherwise false."]
    pub unsafe fn JSCheckScriptSyntax(
        &self,
        ctx: JSContextRef,
        script: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSCheckScriptSyntax)(ctx, script, sourceURL, startingLineNumber, exception)
    }
    #[doc = "@function JSGarbageCollect\n@abstract Performs a JavaScript garbage collection.\n@param ctx The execution context to use.\n@discussion JavaScript values that are on the machine stack, in a register,\nprotected by JSValueProtect, set as the global object of an execution context,\nor reachable from any such value will not be collected.\n\nDuring JavaScript execution, you are not required to call this function; the\nJavaScript engine will garbage collect as needed. JavaScript values created\nwithin a context group are automatically destroyed when the last reference\nto the context group is released."]
    pub unsafe fn JSGarbageCollect(&self, ctx: JSContextRef) {
        (self.JSGarbageCollect)(ctx)
    }
    #[doc = "@function\n@abstract       Returns a JavaScript value's type.\n@param ctx  The execution context to use.\n@param value    The JSValue whose type you want to obtain.\n@result         A value of type JSType that identifies value's type."]
    pub unsafe fn JSValueGetType(&self, ctx: JSContextRef, value: JSValueRef) -> JSType {
        (self.JSValueGetType)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the undefined type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the undefined type, otherwise false."]
    pub unsafe fn JSValueIsUndefined(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsUndefined)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the null type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the null type, otherwise false."]
    pub unsafe fn JSValueIsNull(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsNull)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the boolean type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the boolean type, otherwise false."]
    pub unsafe fn JSValueIsBoolean(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsBoolean)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the number type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the number type, otherwise false."]
    pub unsafe fn JSValueIsNumber(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsNumber)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the string type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the string type, otherwise false."]
    pub unsafe fn JSValueIsString(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsString)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the symbol type.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the symbol type, otherwise false."]
    pub unsafe fn JSValueIsSymbol(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsSymbol)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value's type is the object type.\n@param ctx  The execution context to use.\n@param value    The JSValue to test.\n@result         true if value's type is the object type, otherwise false."]
    pub unsafe fn JSValueIsObject(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsObject)(ctx, value)
    }
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object with a given class in its class chain.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param jsClass The JSClass to test against.\n@result true if value is an object and has jsClass in its class chain, otherwise false."]
    pub unsafe fn JSValueIsObjectOfClass(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        jsClass: JSClassRef,
    ) -> bool {
        (self.JSValueIsObjectOfClass)(ctx, value, jsClass)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is an array.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is an array, otherwise false."]
    pub unsafe fn JSValueIsArray(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsArray)(ctx, value)
    }
    #[doc = "@function\n@abstract       Tests whether a JavaScript value is a date.\n@param ctx      The execution context to use.\n@param value    The JSValue to test.\n@result         true if value is a date, otherwise false."]
    pub unsafe fn JSValueIsDate(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueIsDate)(ctx, value)
    }
    #[doc = "@function\n@abstract           Returns a JavaScript value's Typed Array type.\n@param ctx          The execution context to use.\n@param value        The JSValue whose Typed Array type to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object."]
    pub unsafe fn JSValueGetTypedArrayType(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType {
        (self.JSValueGetTypedArrayType)(ctx, value, exception)
    }
    #[doc = "@function\n@abstract Tests whether two JavaScript values are equal, as compared by the JS == operator.\n@param ctx The execution context to use.\n@param a The first value to test.\n@param b The second value to test.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the two values are equal, false if they are not equal or an exception is thrown."]
    pub unsafe fn JSValueIsEqual(
        &self,
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSValueIsEqual)(ctx, a, b, exception)
    }
    #[doc = "@function\n@abstract       Tests whether two JavaScript values are strict equal, as compared by the JS === operator.\n@param ctx  The execution context to use.\n@param a        The first value to test.\n@param b        The second value to test.\n@result         true if the two values are strict equal, otherwise false."]
    pub unsafe fn JSValueIsStrictEqual(
        &self,
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
    ) -> bool {
        (self.JSValueIsStrictEqual)(ctx, a, b)
    }
    #[doc = "@function\n@abstract Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.\n@param ctx The execution context to use.\n@param value The JSValue to test.\n@param constructor The constructor to test against.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false."]
    pub unsafe fn JSValueIsInstanceOfConstructor(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSValueIsInstanceOfConstructor)(ctx, value, constructor, exception)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value of the undefined type.\n@param ctx  The execution context to use.\n@result         The unique undefined value."]
    pub unsafe fn JSValueMakeUndefined(&self, ctx: JSContextRef) -> JSValueRef {
        (self.JSValueMakeUndefined)(ctx)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value of the null type.\n@param ctx  The execution context to use.\n@result         The unique null value."]
    pub unsafe fn JSValueMakeNull(&self, ctx: JSContextRef) -> JSValueRef {
        (self.JSValueMakeNull)(ctx)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value of the boolean type.\n@param ctx  The execution context to use.\n@param boolean  The bool to assign to the newly created JSValue.\n@result         A JSValue of the boolean type, representing the value of boolean."]
    pub unsafe fn JSValueMakeBoolean(&self, ctx: JSContextRef, boolean: bool) -> JSValueRef {
        (self.JSValueMakeBoolean)(ctx, boolean)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value of the number type.\n@param ctx  The execution context to use.\n@param number   The double to assign to the newly created JSValue.\n@result         A JSValue of the number type, representing the value of number."]
    pub unsafe fn JSValueMakeNumber(&self, ctx: JSContextRef, number: f64) -> JSValueRef {
        (self.JSValueMakeNumber)(ctx, number)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value of the string type.\n@param ctx  The execution context to use.\n@param string   The JSString to assign to the newly created JSValue. The\nnewly created JSValue retains string, and releases it upon garbage collection.\n@result         A JSValue of the string type, representing the value of string."]
    pub unsafe fn JSValueMakeString(&self, ctx: JSContextRef, string: JSStringRef) -> JSValueRef {
        (self.JSValueMakeString)(ctx, string)
    }
    #[doc = "@function\n@abstract            Creates a JavaScript value of the symbol type.\n@param ctx           The execution context to use.\n@param description   A description of the newly created symbol value.\n@result              A unique JSValue of the symbol type, whose description matches the one provided."]
    pub unsafe fn JSValueMakeSymbol(
        &self,
        ctx: JSContextRef,
        description: JSStringRef,
    ) -> JSValueRef {
        (self.JSValueMakeSymbol)(ctx, description)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript value from a JSON formatted string.\n@param ctx      The execution context to use.\n@param string   The JSString containing the JSON string to be parsed.\n@result         A JSValue containing the parsed value, or NULL if the input is invalid."]
    pub unsafe fn JSValueMakeFromJSONString(
        &self,
        ctx: JSContextRef,
        string: JSStringRef,
    ) -> JSValueRef {
        (self.JSValueMakeFromJSONString)(ctx, string)
    }
    #[doc = "@function\n@abstract       Creates a JavaScript string containing the JSON serialized representation of a JS value.\n@param ctx      The execution context to use.\n@param value    The value to serialize.\n@param indent   The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of serialization, or NULL if an exception is thrown."]
    pub unsafe fn JSValueCreateJSONString(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        indent: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        (self.JSValueCreateJSONString)(ctx, value, indent, exception)
    }
    #[doc = "@function\n@abstract       Converts a JavaScript value to boolean and returns the resulting boolean.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@result         The boolean result of conversion."]
    pub unsafe fn JSValueToBoolean(&self, ctx: JSContextRef, value: JSValueRef) -> bool {
        (self.JSValueToBoolean)(ctx, value)
    }
    #[doc = "@function\n@abstract       Converts a JavaScript value to number and returns the resulting number.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The numeric result of conversion, or NaN if an exception is thrown."]
    pub unsafe fn JSValueToNumber(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> f64 {
        (self.JSValueToNumber)(ctx, value, exception)
    }
    #[doc = "@function\n@abstract       Converts a JavaScript value to string and copies the result into a JavaScript string.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule."]
    pub unsafe fn JSValueToStringCopy(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        (self.JSValueToStringCopy)(ctx, value, exception)
    }
    #[doc = "@function\n@abstract Converts a JavaScript value to object and returns the resulting object.\n@param ctx  The execution context to use.\n@param value    The JSValue to convert.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result         The JSObject result of conversion, or NULL if an exception is thrown."]
    pub unsafe fn JSValueToObject(
        &self,
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSValueToObject)(ctx, value, exception)
    }
    #[doc = "@function\n@abstract Protects a JavaScript value from garbage collection.\n@param ctx The execution context to use.\n@param value The JSValue to protect.\n@discussion Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.\n\nA value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection."]
    pub unsafe fn JSValueProtect(&self, ctx: JSContextRef, value: JSValueRef) {
        (self.JSValueProtect)(ctx, value)
    }
    #[doc = "@function\n@abstract       Unprotects a JavaScript value from garbage collection.\n@param ctx      The execution context to use.\n@param value    The JSValue to unprotect.\n@discussion     A value may be protected multiple times and must be unprotected an\nequal number of times before becoming eligible for garbage collection."]
    pub unsafe fn JSValueUnprotect(&self, ctx: JSContextRef, value: JSValueRef) {
        (self.JSValueUnprotect)(ctx, value)
    }
    #[doc = "@function\n@abstract Creates a JavaScript class suitable for use with JSObjectMake.\n@param definition A JSClassDefinition that defines the class.\n@result A JSClass with the given definition. Ownership follows the Create Rule."]
    pub unsafe fn JSClassCreate(&self, definition: *const JSClassDefinition) -> JSClassRef {
        (self.JSClassCreate)(definition)
    }
    #[doc = "@function\n@abstract Retains a JavaScript class.\n@param jsClass The JSClass to retain.\n@result A JSClass that is the same as jsClass."]
    pub unsafe fn JSClassRetain(&self, jsClass: JSClassRef) -> JSClassRef {
        (self.JSClassRetain)(jsClass)
    }
    #[doc = "@function\n@abstract Releases a JavaScript class.\n@param jsClass The JSClass to release."]
    pub unsafe fn JSClassRelease(&self, jsClass: JSClassRef) {
        (self.JSClassRelease)(jsClass)
    }
    #[doc = "@function\n@abstract Creates a JavaScript object.\n@param ctx The execution context to use.\n@param jsClass The JSClass to assign to the object. Pass NULL to use the default object class.\n@param data A void* to set as the object's private data. Pass NULL to specify no private data.\n@result A JSObject with the given class and private data.\n@discussion The default object class does not allocate storage for private data, so you must provide a non-NULL jsClass to JSObjectMake if you want your object to be able to store private data.\n\ndata is set on the created object before the intialize methods in its class chain are called. This enables the initialize methods to retrieve and manipulate data through JSObjectGetPrivate."]
    pub unsafe fn JSObjectMake(
        &self,
        ctx: JSContextRef,
        jsClass: JSClassRef,
        data: *mut ::std::os::raw::c_void,
    ) -> JSObjectRef {
        (self.JSObjectMake)(ctx, jsClass, data)
    }
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript function with a given callback as its implementation.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param callAsFunction The JSObjectCallAsFunctionCallback to invoke when the function is called.\n@result A JSObject that is a function. The object's prototype will be the default function prototype."]
    pub unsafe fn JSObjectMakeFunctionWithCallback(
        &self,
        ctx: JSContextRef,
        name: JSStringRef,
        callAsFunction: JSObjectCallAsFunctionCallback,
    ) -> JSObjectRef {
        (self.JSObjectMakeFunctionWithCallback)(ctx, name, callAsFunction)
    }
    #[doc = "@function\n@abstract Convenience method for creating a JavaScript constructor.\n@param ctx The execution context to use.\n@param jsClass A JSClass that is the class your constructor will assign to the objects its constructs. jsClass will be used to set the constructor's .prototype property, and to evaluate 'instanceof' expressions. Pass NULL to use the default object class.\n@param callAsConstructor A JSObjectCallAsConstructorCallback to invoke when your constructor is used in a 'new' expression. Pass NULL to use the default object constructor.\n@result A JSObject that is a constructor. The object's prototype will be the default object prototype.\n@discussion The default object constructor takes no arguments and constructs an object of class jsClass with no private data. If the constructor is inherited via JS subclassing and the value returned from callAsConstructor was created with jsClass, then the returned object will have it's prototype overridden to the derived class's prototype."]
    pub unsafe fn JSObjectMakeConstructor(
        &self,
        ctx: JSContextRef,
        jsClass: JSClassRef,
        callAsConstructor: JSObjectCallAsConstructorCallback,
    ) -> JSObjectRef {
        (self.JSObjectMakeConstructor)(ctx, jsClass, callAsConstructor)
    }
    #[doc = "@function\n@abstract Creates a JavaScript Array object.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of data to populate the Array with. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Array.\n@discussion The behavior of this function does not exactly match the behavior of the built-in Array constructor. Specifically, if one argument\nis supplied, this function returns an array with one element."]
    pub unsafe fn JSObjectMakeArray(
        &self,
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeArray)(ctx, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Creates a JavaScript Date object, as if by invoking the built-in Date constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Date Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a Date."]
    pub unsafe fn JSObjectMakeDate(
        &self,
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeDate)(ctx, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Creates a JavaScript Error object, as if by invoking the built-in Error constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the Error Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is an Error."]
    pub unsafe fn JSObjectMakeError(
        &self,
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeError)(ctx, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Creates a JavaScript RegExp object, as if by invoking the built-in RegExp constructor.\n@param ctx The execution context to use.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the RegExp Constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a RegExp."]
    pub unsafe fn JSObjectMakeRegExp(
        &self,
        ctx: JSContextRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeRegExp)(ctx, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Creates a JavaScript promise object by invoking the provided executor.\n@param ctx The execution context to use.\n@param resolve A pointer to a JSObjectRef in which to store the resolve function for the new promise. Pass NULL if you do not care to store the resolve callback.\n@param reject A pointer to a JSObjectRef in which to store the reject function for the new promise. Pass NULL if you do not care to store the reject callback.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result A JSObject that is a promise or NULL if an exception occurred."]
    pub unsafe fn JSObjectMakeDeferredPromise(
        &self,
        ctx: JSContextRef,
        resolve: *mut JSObjectRef,
        reject: *mut JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeDeferredPromise)(ctx, resolve, reject, exception)
    }
    #[doc = "@function\n@abstract Creates a function with a given script as its body.\n@param ctx The execution context to use.\n@param name A JSString containing the function's name. This will be used when converting the function to string. Pass NULL to create an anonymous function.\n@param parameterCount An integer count of the number of parameter names in parameterNames.\n@param parameterNames A JSString array containing the names of the function's parameters. Pass NULL if parameterCount is 0.\n@param body A JSString containing the script to use as the function's body.\n@param sourceURL A JSString containing a URL for the script's source file. This is only used when reporting exceptions. Pass NULL if you do not care to include source file information in exceptions.\n@param startingLineNumber An integer value specifying the script's starting line number in the file located at sourceURL. This is only used when reporting exceptions. The value is one-based, so the first line is line 1 and invalid values are clamped to 1.\n@param exception A pointer to a JSValueRef in which to store a syntax error exception, if any. Pass NULL if you do not care to store a syntax error exception.\n@result A JSObject that is a function, or NULL if either body or parameterNames contains a syntax error. The object's prototype will be the default function prototype.\n@discussion Use this method when you want to execute a script repeatedly, to avoid the cost of re-parsing the script before each execution."]
    pub unsafe fn JSObjectMakeFunction(
        &self,
        ctx: JSContextRef,
        name: JSStringRef,
        parameterCount: ::std::os::raw::c_uint,
        parameterNames: *const JSStringRef,
        body: JSStringRef,
        sourceURL: JSStringRef,
        startingLineNumber: ::std::os::raw::c_int,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeFunction)(
            ctx,
            name,
            parameterCount,
            parameterNames,
            body,
            sourceURL,
            startingLineNumber,
            exception,
        )
    }
    #[doc = "@function\n@abstract Gets an object's prototype.\n@param ctx  The execution context to use.\n@param object A JSObject whose prototype you want to get.\n@result A JSValue that is the object's prototype."]
    pub unsafe fn JSObjectGetPrototype(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
    ) -> JSValueRef {
        (self.JSObjectGetPrototype)(ctx, object)
    }
    #[doc = "@function\n@abstract Sets an object's prototype.\n@param ctx  The execution context to use.\n@param object The JSObject whose prototype you want to set.\n@param value A JSValue to set as the object's prototype."]
    pub unsafe fn JSObjectSetPrototype(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        value: JSValueRef,
    ) {
        (self.JSObjectSetPrototype)(ctx, object, value)
    }
    #[doc = "@function\n@abstract Tests whether an object has a given property.\n@param object The JSObject to test.\n@param propertyName A JSString containing the property's name.\n@result true if the object has a property whose name matches propertyName, otherwise false."]
    pub unsafe fn JSObjectHasProperty(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
    ) -> bool {
        (self.JSObjectHasProperty)(ctx, object, propertyName)
    }
    #[doc = "@function\n@abstract Gets a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value."]
    pub unsafe fn JSObjectGetProperty(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef {
        (self.JSObjectGetProperty)(ctx, object, propertyName, exception)
    }
    #[doc = "@function\n@abstract Sets a property on an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyName A JSString containing the property's name.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception."]
    pub unsafe fn JSObjectSetProperty(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    ) {
        (self.JSObjectSetProperty)(ctx, object, propertyName, value, attributes, exception)
    }
    #[doc = "@function\n@abstract Deletes a property from an object.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyName A JSString containing the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set)."]
    pub unsafe fn JSObjectDeleteProperty(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSObjectDeleteProperty)(ctx, object, propertyName, exception)
    }
    #[doc = "@function\n@abstract Tests whether an object has a given property using a JSValueRef as the property key.\n@param object The JSObject to test.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the object has a property whose name matches propertyKey, otherwise false.\n@discussion This function is the same as performing \"propertyKey in object\" from JavaScript."]
    pub unsafe fn JSObjectHasPropertyForKey(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSObjectHasPropertyForKey)(ctx, object, propertyKey, exception)
    }
    #[doc = "@function\n@abstract Gets a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property key, otherwise the undefined value.\n@discussion This function is the same as performing \"object[propertyKey]\" from JavaScript."]
    pub unsafe fn JSObjectGetPropertyForKey(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef {
        (self.JSObjectGetPropertyForKey)(ctx, object, propertyKey, exception)
    }
    #[doc = "@function\n@abstract Sets a property on an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param value A JSValueRef to use as the property's value.\n@param attributes A logically ORed set of JSPropertyAttributes to give to the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion This function is the same as performing \"object[propertyKey] = value\" from JavaScript."]
    pub unsafe fn JSObjectSetPropertyForKey(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        value: JSValueRef,
        attributes: JSPropertyAttributes,
        exception: *mut JSValueRef,
    ) {
        (self.JSObjectSetPropertyForKey)(ctx, object, propertyKey, value, attributes, exception)
    }
    #[doc = "@function\n@abstract Deletes a property from an object using a JSValueRef as the property key.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to delete.\n@param propertyKey A JSValueRef containing the property key to use when looking up the property.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result true if the delete operation succeeds, otherwise false (for example, if the property has the kJSPropertyAttributeDontDelete attribute set).\n@discussion This function is the same as performing \"delete object[propertyKey]\" from JavaScript."]
    pub unsafe fn JSObjectDeletePropertyForKey(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyKey: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool {
        (self.JSObjectDeletePropertyForKey)(ctx, object, propertyKey, exception)
    }
    #[doc = "@function\n@abstract Gets a property from an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to get.\n@param propertyIndex An integer value that is the property's name.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The property's value if object has the property, otherwise the undefined value.\n@discussion Calling JSObjectGetPropertyAtIndex is equivalent to calling JSObjectGetProperty with a string containing propertyIndex, but JSObjectGetPropertyAtIndex provides optimized access to numeric properties."]
    pub unsafe fn JSObjectGetPropertyAtIndex(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        exception: *mut JSValueRef,
    ) -> JSValueRef {
        (self.JSObjectGetPropertyAtIndex)(ctx, object, propertyIndex, exception)
    }
    #[doc = "@function\n@abstract Sets a property on an object by numeric index.\n@param ctx The execution context to use.\n@param object The JSObject whose property you want to set.\n@param propertyIndex The property's name as a number.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@discussion Calling JSObjectSetPropertyAtIndex is equivalent to calling JSObjectSetProperty with a string containing propertyIndex, but JSObjectSetPropertyAtIndex provides optimized access to numeric properties."]
    pub unsafe fn JSObjectSetPropertyAtIndex(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyIndex: ::std::os::raw::c_uint,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) {
        (self.JSObjectSetPropertyAtIndex)(ctx, object, propertyIndex, value, exception)
    }
    #[doc = "@function\n@abstract Gets an object's private data.\n@param object A JSObject whose private data you want to get.\n@result A void* that is the object's private data, if the object has private data, otherwise NULL."]
    pub unsafe fn JSObjectGetPrivate(&self, object: JSObjectRef) -> *mut ::std::os::raw::c_void {
        (self.JSObjectGetPrivate)(object)
    }
    #[doc = "@function\n@abstract Sets a pointer to private data on an object.\n@param object The JSObject whose private data you want to set.\n@param data A void* to set as the object's private data.\n@result true if object can store private data, otherwise false.\n@discussion The default object class does not allocate storage for private data. Only objects created with a non-NULL JSClass can store private data."]
    pub unsafe fn JSObjectSetPrivate(
        &self,
        object: JSObjectRef,
        data: *mut ::std::os::raw::c_void,
    ) -> bool {
        (self.JSObjectSetPrivate)(object, data)
    }
    #[doc = "@function\n@abstract Tests whether an object can be called as a function.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a function, otherwise false."]
    pub unsafe fn JSObjectIsFunction(&self, ctx: JSContextRef, object: JSObjectRef) -> bool {
        (self.JSObjectIsFunction)(ctx, object)
    }
    #[doc = "@function\n@abstract Calls an object as a function.\n@param ctx The execution context to use.\n@param object The JSObject to call as a function.\n@param thisObject The object to use as \"this,\" or NULL to use the global object as \"this.\"\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the function. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSValue that results from calling object as a function, or NULL if an exception is thrown or object is not a function."]
    pub unsafe fn JSObjectCallAsFunction(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef {
        (self.JSObjectCallAsFunction)(ctx, object, thisObject, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Tests whether an object can be called as a constructor.\n@param ctx  The execution context to use.\n@param object The JSObject to test.\n@result true if the object can be called as a constructor, otherwise false."]
    pub unsafe fn JSObjectIsConstructor(&self, ctx: JSContextRef, object: JSObjectRef) -> bool {
        (self.JSObjectIsConstructor)(ctx, object)
    }
    #[doc = "@function\n@abstract Calls an object as a constructor.\n@param ctx The execution context to use.\n@param object The JSObject to call as a constructor.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of arguments to pass to the constructor. Pass NULL if argumentCount is 0.\n@param exception A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result The JSObject that results from calling object as a constructor, or NULL if an exception is thrown or object is not a constructor."]
    pub unsafe fn JSObjectCallAsConstructor(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectCallAsConstructor)(ctx, object, argumentCount, arguments, exception)
    }
    #[doc = "@function\n@abstract Gets the names of an object's enumerable properties.\n@param ctx The execution context to use.\n@param object The object whose property names you want to get.\n@result A JSPropertyNameArray containing the names object's enumerable properties. Ownership follows the Create Rule."]
    pub unsafe fn JSObjectCopyPropertyNames(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
    ) -> JSPropertyNameArrayRef {
        (self.JSObjectCopyPropertyNames)(ctx, object)
    }
    #[doc = "@function\n@abstract Retains a JavaScript property name array.\n@param array The JSPropertyNameArray to retain.\n@result A JSPropertyNameArray that is the same as array."]
    pub unsafe fn JSPropertyNameArrayRetain(
        &self,
        array: JSPropertyNameArrayRef,
    ) -> JSPropertyNameArrayRef {
        (self.JSPropertyNameArrayRetain)(array)
    }
    #[doc = "@function\n@abstract Releases a JavaScript property name array.\n@param array The JSPropetyNameArray to release."]
    pub unsafe fn JSPropertyNameArrayRelease(&self, array: JSPropertyNameArrayRef) {
        (self.JSPropertyNameArrayRelease)(array)
    }
    #[doc = "@function\n@abstract Gets a count of the number of items in a JavaScript property name array.\n@param array The array from which to retrieve the count.\n@result An integer count of the number of names in array."]
    pub unsafe fn JSPropertyNameArrayGetCount(&self, array: JSPropertyNameArrayRef) -> usize {
        (self.JSPropertyNameArrayGetCount)(array)
    }
    #[doc = "@function\n@abstract Gets a property name at a given index in a JavaScript property name array.\n@param array The array from which to retrieve the property name.\n@param index The index of the property name to retrieve.\n@result A JSStringRef containing the property name."]
    pub unsafe fn JSPropertyNameArrayGetNameAtIndex(
        &self,
        array: JSPropertyNameArrayRef,
        index: usize,
    ) -> JSStringRef {
        (self.JSPropertyNameArrayGetNameAtIndex)(array, index)
    }
    #[doc = "@function\n@abstract Adds a property name to a JavaScript property name accumulator.\n@param accumulator The accumulator object to which to add the property name.\n@param propertyName The property name to add."]
    pub unsafe fn JSPropertyNameAccumulatorAddName(
        &self,
        accumulator: JSPropertyNameAccumulatorRef,
        propertyName: JSStringRef,
    ) {
        (self.JSPropertyNameAccumulatorAddName)(accumulator, propertyName)
    }
    #[doc = "@function\n@abstract Creates a JavaScript context group.\n@discussion A JSContextGroup associates JavaScript contexts with one another.\nContexts in the same group may share and exchange JavaScript objects. Sharing and/or exchanging\nJavaScript objects between contexts in different groups will produce undefined behavior.\nWhen objects from the same context group are used in multiple threads, explicit\nsynchronization is required.\n\nA JSContextGroup may need to run deferred tasks on a run loop, such as garbage collection\nor resolving WebAssembly compilations. By default, calling JSContextGroupCreate will use\nthe run loop of the thread it was called on. Currently, there is no API to change a\nJSContextGroup's run loop once it has been created.\n@result The created JSContextGroup."]
    pub unsafe fn JSContextGroupCreate(&self) -> JSContextGroupRef {
        (self.JSContextGroupCreate)()
    }
    #[doc = "@function\n@abstract Retains a JavaScript context group.\n@param group The JSContextGroup to retain.\n@result A JSContextGroup that is the same as group."]
    pub unsafe fn JSContextGroupRetain(&self, group: JSContextGroupRef) -> JSContextGroupRef {
        (self.JSContextGroupRetain)(group)
    }
    #[doc = "@function\n@abstract Releases a JavaScript context group.\n@param group The JSContextGroup to release."]
    pub unsafe fn JSContextGroupRelease(&self, group: JSContextGroupRef) {
        (self.JSContextGroupRelease)(group)
    }
    #[doc = "@function\n@abstract Creates a global JavaScript execution context.\n@discussion JSGlobalContextCreate allocates a global object and populates it with all the\nbuilt-in JavaScript objects, such as Object, Function, String, and Array.\n\nIn WebKit version 4.0 and later, the context is created in a unique context group.\nTherefore, scripts may execute in it concurrently with scripts executing in other contexts.\nHowever, you may not use values created in the context in other contexts.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@result A JSGlobalContext with a global object of class globalObjectClass."]
    pub unsafe fn JSGlobalContextCreate(
        &self,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef {
        (self.JSGlobalContextCreate)(globalObjectClass)
    }
    #[doc = "@function\n@abstract Creates a global JavaScript execution context in the context group provided.\n@discussion JSGlobalContextCreateInGroup allocates a global object and populates it with\nall the built-in JavaScript objects, such as Object, Function, String, and Array.\n@param globalObjectClass The class to use when creating the global object. Pass\nNULL to use the default object class.\n@param group The context group to use. The created global context retains the group.\nPass NULL to create a unique group for the context.\n@result A JSGlobalContext with a global object of class globalObjectClass and a context\ngroup equal to group."]
    pub unsafe fn JSGlobalContextCreateInGroup(
        &self,
        group: JSContextGroupRef,
        globalObjectClass: JSClassRef,
    ) -> JSGlobalContextRef {
        (self.JSGlobalContextCreateInGroup)(group, globalObjectClass)
    }
    #[doc = "@function\n@abstract Retains a global JavaScript execution context.\n@param ctx The JSGlobalContext to retain.\n@result A JSGlobalContext that is the same as ctx."]
    pub unsafe fn JSGlobalContextRetain(&self, ctx: JSGlobalContextRef) -> JSGlobalContextRef {
        (self.JSGlobalContextRetain)(ctx)
    }
    #[doc = "@function\n@abstract Releases a global JavaScript execution context.\n@param ctx The JSGlobalContext to release."]
    pub unsafe fn JSGlobalContextRelease(&self, ctx: JSGlobalContextRef) {
        (self.JSGlobalContextRelease)(ctx)
    }
    #[doc = "@function\n@abstract Gets the global object of a JavaScript execution context.\n@param ctx The JSContext whose global object you want to get.\n@result ctx's global object."]
    pub unsafe fn JSContextGetGlobalObject(&self, ctx: JSContextRef) -> JSObjectRef {
        (self.JSContextGetGlobalObject)(ctx)
    }
    #[doc = "@function\n@abstract Gets the context group to which a JavaScript execution context belongs.\n@param ctx The JSContext whose group you want to get.\n@result ctx's group."]
    pub unsafe fn JSContextGetGroup(&self, ctx: JSContextRef) -> JSContextGroupRef {
        (self.JSContextGetGroup)(ctx)
    }
    #[doc = "@function\n@abstract Gets the global context of a JavaScript execution context.\n@param ctx The JSContext whose global context you want to get.\n@result ctx's global context."]
    pub unsafe fn JSContextGetGlobalContext(&self, ctx: JSContextRef) -> JSGlobalContextRef {
        (self.JSContextGetGlobalContext)(ctx)
    }
    #[doc = "@function\n@abstract Gets a copy of the name of a context.\n@param ctx The JSGlobalContext whose name you want to get.\n@result The name for ctx.\n@discussion A JSGlobalContext's name is exposed when inspecting the context to make it easier to identify the context you would like to inspect."]
    pub unsafe fn JSGlobalContextCopyName(&self, ctx: JSGlobalContextRef) -> JSStringRef {
        (self.JSGlobalContextCopyName)(ctx)
    }
    #[doc = "@function\n@abstract Sets the name exposed when inspecting a context.\n@param ctx The JSGlobalContext that you want to name.\n@param name The name to set on the context."]
    pub unsafe fn JSGlobalContextSetName(&self, ctx: JSGlobalContextRef, name: JSStringRef) {
        (self.JSGlobalContextSetName)(ctx, name)
    }
    #[doc = "@function\n@abstract Gets whether the context is inspectable in Web Inspector.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@result Whether the context is inspectable in Web Inspector."]
    pub unsafe fn JSGlobalContextIsInspectable(&self, ctx: JSGlobalContextRef) -> bool {
        (self.JSGlobalContextIsInspectable)(ctx)
    }
    #[doc = "@function\n@abstract Sets whether the context is inspectable in Web Inspector. Default value is NO.\n@param ctx The JSGlobalContext that you want to change the inspectability of.\n@param inspectable YES to allow Web Inspector to connect to the context, otherwise NO."]
    pub unsafe fn JSGlobalContextSetInspectable(&self, ctx: JSGlobalContextRef, inspectable: bool) {
        (self.JSGlobalContextSetInspectable)(ctx, inspectable)
    }
    #[doc = "@function\n@abstract         Creates a JavaScript string from a buffer of Unicode characters.\n@param chars      The buffer of Unicode characters to copy into the new JSString.\n@param numChars   The number of characters to copy from the buffer pointed to by chars.\n@result           A JSString containing chars. Ownership follows the Create Rule."]
    pub unsafe fn JSStringCreateWithCharacters(
        &self,
        chars: *const JSChar,
        numChars: usize,
    ) -> JSStringRef {
        (self.JSStringCreateWithCharacters)(chars, numChars)
    }
    #[doc = "@function\n@abstract         Creates a JavaScript string from a null-terminated UTF8 string.\n@param string     The null-terminated UTF8 string to copy into the new JSString.\n@result           A JSString containing string. Ownership follows the Create Rule."]
    pub unsafe fn JSStringCreateWithUTF8CString(
        &self,
        string: *const ::std::os::raw::c_char,
    ) -> JSStringRef {
        (self.JSStringCreateWithUTF8CString)(string)
    }
    #[doc = "@function\n@abstract         Retains a JavaScript string.\n@param string     The JSString to retain.\n@result           A JSString that is the same as string."]
    pub unsafe fn JSStringRetain(&self, string: JSStringRef) -> JSStringRef {
        (self.JSStringRetain)(string)
    }
    #[doc = "@function\n@abstract         Releases a JavaScript string.\n@param string     The JSString to release."]
    pub unsafe fn JSStringRelease(&self, string: JSStringRef) {
        (self.JSStringRelease)(string)
    }
    #[doc = "@function\n@abstract         Returns the number of Unicode characters in a JavaScript string.\n@param string     The JSString whose length (in Unicode characters) you want to know.\n@result           The number of Unicode characters stored in string."]
    pub unsafe fn JSStringGetLength(&self, string: JSStringRef) -> usize {
        (self.JSStringGetLength)(string)
    }
    #[doc = "@function\n@abstract         Returns a pointer to the Unicode character buffer that\nserves as the backing store for a JavaScript string.\n@param string     The JSString whose backing store you want to access.\n@result           A pointer to the Unicode character buffer that serves as string's\nbacking store, which will be deallocated when string is deallocated."]
    pub unsafe fn JSStringGetCharactersPtr(&self, string: JSStringRef) -> *const JSChar {
        (self.JSStringGetCharactersPtr)(string)
    }
    #[doc = "@function\n@abstract Returns the maximum number of bytes a JavaScript string will\ntake up if converted into a null-terminated UTF8 string.\n@param string The JSString whose maximum converted size (in bytes) you\nwant to know.\n@result The maximum number of bytes that could be required to convert string into a\nnull-terminated UTF8 string. The number of bytes that the conversion actually ends\nup requiring could be less than this, but never more."]
    pub unsafe fn JSStringGetMaximumUTF8CStringSize(&self, string: JSStringRef) -> usize {
        (self.JSStringGetMaximumUTF8CStringSize)(string)
    }
    #[doc = "@function\n@abstract Converts a JavaScript string into a null-terminated UTF8 string,\nand copies the result into an external byte buffer.\n@param string The source JSString.\n@param buffer The destination byte buffer into which to copy a null-terminated\nUTF8 representation of string. On return, buffer contains a UTF8 string\nrepresentation of string. If bufferSize is too small, buffer will contain only\npartial results. If buffer is not at least bufferSize bytes in size,\nbehavior is undefined.\n@param bufferSize The size of the external buffer in bytes.\n@result The number of bytes written into buffer (including the null-terminator byte)."]
    pub unsafe fn JSStringGetUTF8CString(
        &self,
        string: JSStringRef,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> usize {
        (self.JSStringGetUTF8CString)(string, buffer, bufferSize)
    }
    #[doc = "@function\n@abstract     Tests whether two JavaScript strings match.\n@param a      The first JSString to test.\n@param b      The second JSString to test.\n@result       true if the two strings match, otherwise false."]
    pub unsafe fn JSStringIsEqual(&self, a: JSStringRef, b: JSStringRef) -> bool {
        (self.JSStringIsEqual)(a, b)
    }
    #[doc = "@function\n@abstract     Tests whether a JavaScript string matches a null-terminated UTF8 string.\n@param a      The JSString to test.\n@param b      The null-terminated UTF8 string to test.\n@result       true if the two strings match, otherwise false."]
    pub unsafe fn JSStringIsEqualToUTF8CString(
        &self,
        a: JSStringRef,
        b: *const ::std::os::raw::c_char,
    ) -> bool {
        (self.JSStringIsEqualToUTF8CString)(a, b)
    }
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object with the given number of elements.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param length       The number of elements to be in the new Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array with all elements set to zero or NULL if there was an error."]
    pub unsafe fn JSObjectMakeTypedArray(
        &self,
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeTypedArray)(ctx, arrayType, length, exception)
    }
    #[doc = "@function\n@abstract                 Creates a JavaScript Typed Array object from an existing pointer.\n@param ctx                The execution context to use.\n@param arrayType          A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the JSTypedArrayData object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Typed Array whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub unsafe fn JSObjectMakeTypedArrayWithBytesNoCopy(
        &self,
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeTypedArrayWithBytesNoCopy)(
            ctx,
            arrayType,
            bytes,
            byteLength,
            bytesDeallocator,
            deallocatorContext,
            exception,
        )
    }
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub unsafe fn JSObjectMakeTypedArrayWithArrayBuffer(
        &self,
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeTypedArrayWithArrayBuffer)(ctx, arrayType, buffer, exception)
    }
    #[doc = "@function\n@abstract           Creates a JavaScript Typed Array object from an existing JavaScript Array Buffer object with the given offset and length.\n@param ctx          The execution context to use.\n@param arrayType    A value identifying the type of array to create. If arrayType is kJSTypedArrayTypeNone or kJSTypedArrayTypeArrayBuffer then NULL will be returned.\n@param buffer       An Array Buffer object that should be used as the backing store for the created JavaScript Typed Array object.\n@param byteOffset   The byte offset for the created Typed Array. byteOffset should aligned with the element size of arrayType.\n@param length       The number of elements to include in the Typed Array.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef that is a Typed Array or NULL if there was an error. The backing store of the Typed Array will be buffer."]
    pub unsafe fn JSObjectMakeTypedArrayWithArrayBufferAndOffset(
        &self,
        ctx: JSContextRef,
        arrayType: JSTypedArrayType,
        buffer: JSObjectRef,
        byteOffset: usize,
        length: usize,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeTypedArrayWithArrayBufferAndOffset)(
            ctx, arrayType, buffer, byteOffset, length, exception,
        )
    }
    #[doc = "@function\n@abstract           Returns a temporary pointer to the backing store of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose backing store pointer to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A pointer to the raw data buffer that serves as object's backing store or NULL if object is not a Typed Array object.\n@discussion         The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub unsafe fn JSObjectGetTypedArrayBytesPtr(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void {
        (self.JSObjectGetTypedArrayBytesPtr)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract           Returns the length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub unsafe fn JSObjectGetTypedArrayLength(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize {
        (self.JSObjectGetTypedArrayLength)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract           Returns the byte length of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte length to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte length of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub unsafe fn JSObjectGetTypedArrayByteLength(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize {
        (self.JSObjectGetTypedArrayByteLength)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract           Returns the byte offset of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The Typed Array object whose byte offset to return.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             The byte offset of the Typed Array object or 0 if the object is not a Typed Array object."]
    pub unsafe fn JSObjectGetTypedArrayByteOffset(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize {
        (self.JSObjectGetTypedArrayByteOffset)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract           Returns the JavaScript Array Buffer object that is used as the backing of a JavaScript Typed Array object.\n@param ctx          The execution context to use.\n@param object       The JSObjectRef whose Typed Array type data pointer to obtain.\n@param exception    A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result             A JSObjectRef with a JSTypedArrayType of kJSTypedArrayTypeArrayBuffer or NULL if object is not a Typed Array."]
    pub unsafe fn JSObjectGetTypedArrayBuffer(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectGetTypedArrayBuffer)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract                 Creates a JavaScript Array Buffer object from an existing pointer.\n@param ctx                The execution context to use.\n@param bytes              A pointer to the byte buffer to be used as the backing store of the Typed Array object.\n@param byteLength         The number of bytes pointed to by the parameter bytes.\n@param bytesDeallocator   The allocator to use to deallocate the external buffer when the Typed Array data object is deallocated.\n@param deallocatorContext A pointer to pass back to the deallocator.\n@param exception          A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result                   A JSObjectRef Array Buffer whose backing store is the same as the one pointed to by bytes or NULL if there was an error.\n@discussion               If an exception is thrown during this function the bytesDeallocator will always be called."]
    pub unsafe fn JSObjectMakeArrayBufferWithBytesNoCopy(
        &self,
        ctx: JSContextRef,
        bytes: *mut ::std::os::raw::c_void,
        byteLength: usize,
        bytesDeallocator: JSTypedArrayBytesDeallocator,
        deallocatorContext: *mut ::std::os::raw::c_void,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        (self.JSObjectMakeArrayBufferWithBytesNoCopy)(
            ctx,
            bytes,
            byteLength,
            bytesDeallocator,
            deallocatorContext,
            exception,
        )
    }
    #[doc = "@function\n@abstract         Returns a pointer to the data buffer that serves as the backing store for a JavaScript Typed Array object.\n@param object     The Array Buffer object whose internal backing store pointer to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           A pointer to the raw data buffer that serves as object's backing store or NULL if object is not an Array Buffer object.\n@discussion       The pointer returned by this function is temporary and is not guaranteed to remain valid across JavaScriptCore API calls."]
    pub unsafe fn JSObjectGetArrayBufferBytesPtr(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> *mut ::std::os::raw::c_void {
        (self.JSObjectGetArrayBufferBytesPtr)(ctx, object, exception)
    }
    #[doc = "@function\n@abstract         Returns the number of bytes in a JavaScript data object.\n@param ctx        The execution context to use.\n@param object     The JS Arary Buffer object whose length in bytes to return.\n@param exception  A pointer to a JSValueRef in which to store an exception, if any. Pass NULL if you do not care to store an exception.\n@result           The number of bytes stored in the data object."]
    pub unsafe fn JSObjectGetArrayBufferByteLength(
        &self,
        ctx: JSContextRef,
        object: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> usize {
        (self.JSObjectGetArrayBufferByteLength)(ctx, object, exception)
    }
    #[doc = "\n Get the version string of the library in MAJOR.MINOR.PATCH format.\n"]
    pub unsafe fn ulVersionString(&self) -> *const ::std::os::raw::c_char {
        (self.ulVersionString)()
    }
    #[doc = "\n Get the numeric major version of the library.\n"]
    pub unsafe fn ulVersionMajor(&self) -> ::std::os::raw::c_uint {
        (self.ulVersionMajor)()
    }
    #[doc = "\n Get the numeric minor version of the library.\n"]
    pub unsafe fn ulVersionMinor(&self) -> ::std::os::raw::c_uint {
        (self.ulVersionMinor)()
    }
    #[doc = "\n Get the numeric patch version of the library.\n"]
    pub unsafe fn ulVersionPatch(&self) -> ::std::os::raw::c_uint {
        (self.ulVersionPatch)()
    }
    #[doc = "\n Get the full WebKit version string.\n"]
    pub unsafe fn ulWebKitVersionString(&self) -> *const ::std::os::raw::c_char {
        (self.ulWebKitVersionString)()
    }
    #[doc = "\n Create empty bitmap.\n"]
    pub unsafe fn ulCreateEmptyBitmap(&self) -> ULBitmap {
        (self.ulCreateEmptyBitmap)()
    }
    #[doc = "\n Create bitmap with certain dimensions and pixel format.\n"]
    pub unsafe fn ulCreateBitmap(
        &self,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
    ) -> ULBitmap {
        (self.ulCreateBitmap)(width, height, format)
    }
    #[doc = "\n Create bitmap from existing pixel buffer. @see Bitmap for help using this function.\n"]
    pub unsafe fn ulCreateBitmapFromPixels(
        &self,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: ULBitmapFormat,
        row_bytes: ::std::os::raw::c_uint,
        pixels: *const ::std::os::raw::c_void,
        size: usize,
        should_copy: bool,
    ) -> ULBitmap {
        (self.ulCreateBitmapFromPixels)(width, height, format, row_bytes, pixels, size, should_copy)
    }
    #[doc = "\n Create bitmap from copy.\n"]
    pub unsafe fn ulCreateBitmapFromCopy(&self, existing_bitmap: ULBitmap) -> ULBitmap {
        (self.ulCreateBitmapFromCopy)(existing_bitmap)
    }
    #[doc = "\n Destroy a bitmap (you should only destroy Bitmaps you have explicitly created via one of the\n creation functions above.\n"]
    pub unsafe fn ulDestroyBitmap(&self, bitmap: ULBitmap) {
        (self.ulDestroyBitmap)(bitmap)
    }
    #[doc = "\n Get the width in pixels.\n"]
    pub unsafe fn ulBitmapGetWidth(&self, bitmap: ULBitmap) -> ::std::os::raw::c_uint {
        (self.ulBitmapGetWidth)(bitmap)
    }
    #[doc = "\n Get the height in pixels.\n"]
    pub unsafe fn ulBitmapGetHeight(&self, bitmap: ULBitmap) -> ::std::os::raw::c_uint {
        (self.ulBitmapGetHeight)(bitmap)
    }
    #[doc = "\n Get the pixel format.\n"]
    pub unsafe fn ulBitmapGetFormat(&self, bitmap: ULBitmap) -> ULBitmapFormat {
        (self.ulBitmapGetFormat)(bitmap)
    }
    #[doc = "\n Get the bytes per pixel.\n"]
    pub unsafe fn ulBitmapGetBpp(&self, bitmap: ULBitmap) -> ::std::os::raw::c_uint {
        (self.ulBitmapGetBpp)(bitmap)
    }
    #[doc = "\n Get the number of bytes per row.\n"]
    pub unsafe fn ulBitmapGetRowBytes(&self, bitmap: ULBitmap) -> ::std::os::raw::c_uint {
        (self.ulBitmapGetRowBytes)(bitmap)
    }
    #[doc = "\n Get the size in bytes of the underlying pixel buffer.\n"]
    pub unsafe fn ulBitmapGetSize(&self, bitmap: ULBitmap) -> usize {
        (self.ulBitmapGetSize)(bitmap)
    }
    #[doc = "\n Whether or not this bitmap owns its own pixel buffer.\n"]
    pub unsafe fn ulBitmapOwnsPixels(&self, bitmap: ULBitmap) -> bool {
        (self.ulBitmapOwnsPixels)(bitmap)
    }
    #[doc = "\n Lock pixels for reading/writing, returns pointer to pixel buffer.\n"]
    pub unsafe fn ulBitmapLockPixels(&self, bitmap: ULBitmap) -> *mut ::std::os::raw::c_void {
        (self.ulBitmapLockPixels)(bitmap)
    }
    #[doc = "\n Unlock pixels after locking.\n"]
    pub unsafe fn ulBitmapUnlockPixels(&self, bitmap: ULBitmap) {
        (self.ulBitmapUnlockPixels)(bitmap)
    }
    #[doc = "\n Get raw pixel buffer-- you should only call this if Bitmap is already locked.\n"]
    pub unsafe fn ulBitmapRawPixels(&self, bitmap: ULBitmap) -> *mut ::std::os::raw::c_void {
        (self.ulBitmapRawPixels)(bitmap)
    }
    #[doc = "\n Whether or not this bitmap is empty.\n"]
    pub unsafe fn ulBitmapIsEmpty(&self, bitmap: ULBitmap) -> bool {
        (self.ulBitmapIsEmpty)(bitmap)
    }
    #[doc = "\n Reset bitmap pixels to 0.\n"]
    pub unsafe fn ulBitmapErase(&self, bitmap: ULBitmap) {
        (self.ulBitmapErase)(bitmap)
    }
    #[doc = "\n Write bitmap to a PNG on disk.\n"]
    pub unsafe fn ulBitmapWritePNG(
        &self,
        bitmap: ULBitmap,
        path: *const ::std::os::raw::c_char,
    ) -> bool {
        (self.ulBitmapWritePNG)(bitmap, path)
    }
    #[doc = "\n This converts a BGRA bitmap to RGBA bitmap and vice-versa by swapping the red and blue channels.\n"]
    pub unsafe fn ulBitmapSwapRedBlueChannels(&self, bitmap: ULBitmap) {
        (self.ulBitmapSwapRedBlueChannels)(bitmap)
    }
    #[doc = "\n Create a Buffer from existing, user-owned data without any copies. An optional, user-supplied\n callback will be called to deallocate data upon destruction.\n\n @param  data                  A pointer to the data.\n\n @param  size                  Size of the data in bytes.\n\n @param  user_data             Optional user data that will be passed to destruction_callback\n                               when the returned Buffer is destroyed.\n\n @param  destruction_callback  Optional callback that will be called upon destruction. Pass a\n                               null pointer if you don't want to be informed of destruction.\n"]
    pub unsafe fn ulCreateBuffer(
        &self,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
        destruction_callback: ulDestroyBufferCallback,
    ) -> ULBuffer {
        (self.ulCreateBuffer)(data, size, user_data, destruction_callback)
    }
    #[doc = "\n Create a Buffer from existing data, a deep copy of data will be made.\n"]
    pub unsafe fn ulCreateBufferFromCopy(
        &self,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ULBuffer {
        (self.ulCreateBufferFromCopy)(data, size)
    }
    #[doc = "\n Destroy buffer (you should destroy any buffers you explicitly Create).\n"]
    pub unsafe fn ulDestroyBuffer(&self, buffer: ULBuffer) {
        (self.ulDestroyBuffer)(buffer)
    }
    #[doc = "\n Get a pointer to the raw byte data.\n"]
    pub unsafe fn ulBufferGetData(&self, buffer: ULBuffer) -> *mut ::std::os::raw::c_void {
        (self.ulBufferGetData)(buffer)
    }
    #[doc = "\n Get the size in bytes.\n"]
    pub unsafe fn ulBufferGetSize(&self, buffer: ULBuffer) -> usize {
        (self.ulBufferGetSize)(buffer)
    }
    #[doc = "\n Get the user data associated with this Buffer, if any.\n"]
    pub unsafe fn ulBufferGetUserData(&self, buffer: ULBuffer) -> *mut ::std::os::raw::c_void {
        (self.ulBufferGetUserData)(buffer)
    }
    #[doc = "\n Check whether this Buffer owns its own data (Buffer was created via ulCreateBufferFromCopy).\n If this is false, Buffer will call the user-supplied destruction callback to deallocate data\n when this Buffer instance is destroyed.\n"]
    pub unsafe fn ulBufferOwnsData(&self, buffer: ULBuffer) -> bool {
        (self.ulBufferOwnsData)(buffer)
    }
    #[doc = "\n Create config with default values (see <Ultralight/platform/Config.h>).\n"]
    pub unsafe fn ulCreateConfig(&self) -> ULConfig {
        (self.ulCreateConfig)()
    }
    #[doc = "\n Destroy config.\n"]
    pub unsafe fn ulDestroyConfig(&self, config: ULConfig) {
        (self.ulDestroyConfig)(config)
    }
    #[doc = "\n A writable OS file path to store persistent Session data in.\n\n This data may include cookies, cached network resources, indexed DB, etc.\n\n @note Files are only written to the path when using a persistent Session.\n"]
    pub unsafe fn ulConfigSetCachePath(&self, config: ULConfig, cache_path: ULString) {
        (self.ulConfigSetCachePath)(config, cache_path)
    }
    #[doc = "\n The relative path to the resources folder (loaded via the FileSystem API).\n\n The library loads certain resources (SSL certs, ICU data, etc.) from the FileSystem API\n during runtime (eg, `file:///resources/cacert.pem`).\n\n You can customize the relative file path to the resources folder by modifying this setting.\n\n (Default = \"resources/\")\n"]
    pub unsafe fn ulConfigSetResourcePathPrefix(
        &self,
        config: ULConfig,
        resource_path_prefix: ULString,
    ) {
        (self.ulConfigSetResourcePathPrefix)(config, resource_path_prefix)
    }
    #[doc = "\n The winding order for front-facing triangles.\n\n @pre Only used when GPU rendering is enabled for the View.\n\n (Default = kFaceWinding_CounterClockwise)\n"]
    pub unsafe fn ulConfigSetFaceWinding(&self, config: ULConfig, winding: ULFaceWinding) {
        (self.ulConfigSetFaceWinding)(config, winding)
    }
    #[doc = "\n The hinting algorithm to use when rendering fonts. (Default = kFontHinting_Normal)\n\n @see ULFontHinting\n"]
    pub unsafe fn ulConfigSetFontHinting(&self, config: ULConfig, font_hinting: ULFontHinting) {
        (self.ulConfigSetFontHinting)(config, font_hinting)
    }
    #[doc = "\n The gamma to use when compositing font glyphs, change this value to adjust contrast (Adobe and\n Apple prefer 1.8, others may prefer 2.2). (Default = 1.8)\n"]
    pub unsafe fn ulConfigSetFontGamma(&self, config: ULConfig, font_gamma: f64) {
        (self.ulConfigSetFontGamma)(config, font_gamma)
    }
    #[doc = "\n Global user-defined CSS string (included before any CSS on the page).\n\n You can use this to override default styles for various elements on the page.\n\n @note This is an actual string of CSS, not a file path.\n"]
    pub unsafe fn ulConfigSetUserStylesheet(&self, config: ULConfig, css_string: ULString) {
        (self.ulConfigSetUserStylesheet)(config, css_string)
    }
    #[doc = "\n Whether or not to continuously repaint any Views, regardless if they are dirty.\n\n This is mainly used to diagnose painting/shader issues and profile performance.\n\n (Default = False)\n"]
    pub unsafe fn ulConfigSetForceRepaint(&self, config: ULConfig, enabled: bool) {
        (self.ulConfigSetForceRepaint)(config, enabled)
    }
    #[doc = "\n The delay (in seconds) between every tick of a CSS animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub unsafe fn ulConfigSetAnimationTimerDelay(&self, config: ULConfig, delay: f64) {
        (self.ulConfigSetAnimationTimerDelay)(config, delay)
    }
    #[doc = "\n The delay (in seconds) between every tick of a smooth scroll animation.\n\n (Default = 1.0 / 60.0)\n"]
    pub unsafe fn ulConfigSetScrollTimerDelay(&self, config: ULConfig, delay: f64) {
        (self.ulConfigSetScrollTimerDelay)(config, delay)
    }
    #[doc = "\n The delay (in seconds) between every call to the recycler.\n\n The library attempts to reclaim excess memory during calls to the internal recycler. You can\n change how often this is run by modifying this value.\n\n (Default = 4.0)\n"]
    pub unsafe fn ulConfigSetRecycleDelay(&self, config: ULConfig, delay: f64) {
        (self.ulConfigSetRecycleDelay)(config, delay)
    }
    #[doc = "\n The size of WebCore's memory cache in bytes.\n\n @note  You should increase this if you anticipate handling pages with large resources, Safari\n        typically uses 128+ MiB for its cache.\n\n (Default = 64 * 1024 * 1024)\n"]
    pub unsafe fn ulConfigSetMemoryCacheSize(
        &self,
        config: ULConfig,
        size: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetMemoryCacheSize)(config, size)
    }
    #[doc = "\n The number of pages to keep in the cache. (Default: 0, none)\n\n @note\n \\parblock\n\n Safari typically caches about 5 pages and maintains an on-disk cache to support typical\n web-browsing activities.\n\n If you increase this, you should probably increase the memory cache size as well.\n\n \\endparblock\n\n (Default = 0)\n"]
    pub unsafe fn ulConfigSetPageCacheSize(&self, config: ULConfig, size: ::std::os::raw::c_uint) {
        (self.ulConfigSetPageCacheSize)(config, size)
    }
    #[doc = "\n The system's physical RAM size in bytes.\n\n JavaScriptCore tries to detect the system's physical RAM size to set reasonable allocation\n limits. Set this to anything other than 0 to override the detected value. Size is in bytes.\n\n This can be used to force JavaScriptCore to be more conservative with its allocation strategy\n (at the cost of some performance).\n"]
    pub unsafe fn ulConfigSetOverrideRAMSize(
        &self,
        config: ULConfig,
        size: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetOverrideRAMSize)(config, size)
    }
    #[doc = "\n The minimum size of large VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 32 * 1024 * 1024)\n"]
    pub unsafe fn ulConfigSetMinLargeHeapSize(
        &self,
        config: ULConfig,
        size: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetMinLargeHeapSize)(config, size)
    }
    #[doc = "\n The minimum size of small VM heaps in JavaScriptCore.\n\n Set this to a lower value to make these heaps start with a smaller initial value.\n\n (Default = 1 * 1024 * 1024)\n"]
    pub unsafe fn ulConfigSetMinSmallHeapSize(
        &self,
        config: ULConfig,
        size: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetMinSmallHeapSize)(config, size)
    }
    #[doc = "\n The number of threads to use in the Renderer (for parallel painting on the CPU, etc.).\n\n You can set this to a certain number to limit the number of threads to spawn.\n\n @note\n \\parblock\n\n If this value is 0, the number of threads will be determined at runtime using the following\n formula:\n\n   ```\n   max(PhysicalProcessorCount() - 1, 1)\n   ```\n\n \\endparblock\n"]
    pub unsafe fn ulConfigSetNumRendererThreads(
        &self,
        config: ULConfig,
        num_renderer_threads: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetNumRendererThreads)(config, num_renderer_threads)
    }
    #[doc = "\n The max amount of time (in seconds) to allow repeating timers to run during each call to\n Renderer::Update.\n\n The library will attempt to throttle timers if this time budget is exceeded.\n\n (Default = 1.0 / 200.0)\n"]
    pub unsafe fn ulConfigSetMaxUpdateTime(&self, config: ULConfig, max_update_time: f64) {
        (self.ulConfigSetMaxUpdateTime)(config, max_update_time)
    }
    #[doc = "\n The alignment (in bytes) of the BitmapSurface when using the CPU renderer.\n\n The underlying bitmap associated with each BitmapSurface will have row_bytes padded to reach\n this alignment.\n\n Aligning the bitmap helps improve performance when using the CPU renderer. Determining the\n proper value to use depends on the CPU architecture and max SIMD instruction set used.\n\n We generally target the 128-bit SSE2 instruction set across most PC platforms so '16' is a safe\n value to use.\n\n You can set this to '0' to perform no padding (row_bytes will always be width * 4) at a slight\n cost to performance.\n\n (Default = 16)\n"]
    pub unsafe fn ulConfigSetBitmapAlignment(
        &self,
        config: ULConfig,
        bitmap_alignment: ::std::os::raw::c_uint,
    ) {
        (self.ulConfigSetBitmapAlignment)(config, bitmap_alignment)
    }
    #[doc = "\n Create string from null-terminated ASCII C-string.\n"]
    pub unsafe fn ulCreateString(&self, str_: *const ::std::os::raw::c_char) -> ULString {
        (self.ulCreateString)(str_)
    }
    #[doc = "\n Create string from UTF-8 buffer.\n"]
    pub unsafe fn ulCreateStringUTF8(
        &self,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ULString {
        (self.ulCreateStringUTF8)(str_, len)
    }
    #[doc = "\n Create string from UTF-16 buffer.\n"]
    pub unsafe fn ulCreateStringUTF16(&self, str_: *mut ULChar16, len: usize) -> ULString {
        (self.ulCreateStringUTF16)(str_, len)
    }
    #[doc = "\n Create string from copy of existing string.\n"]
    pub unsafe fn ulCreateStringFromCopy(&self, str_: ULString) -> ULString {
        (self.ulCreateStringFromCopy)(str_)
    }
    #[doc = "\n Destroy string (you should destroy any strings you explicitly Create).\n"]
    pub unsafe fn ulDestroyString(&self, str_: ULString) {
        (self.ulDestroyString)(str_)
    }
    #[doc = "\n Get native UTF-8 buffer data (always null-terminated).\n"]
    pub unsafe fn ulStringGetData(&self, str_: ULString) -> *mut ::std::os::raw::c_char {
        (self.ulStringGetData)(str_)
    }
    #[doc = "\n Get length (in bytes) of the UTF-8 buffer data, not including null terminator.\n"]
    pub unsafe fn ulStringGetLength(&self, str_: ULString) -> usize {
        (self.ulStringGetLength)(str_)
    }
    #[doc = "\n Whether this string is empty or not.\n"]
    pub unsafe fn ulStringIsEmpty(&self, str_: ULString) -> bool {
        (self.ulStringIsEmpty)(str_)
    }
    #[doc = "\n Replaces the contents of 'str' with the contents of 'new_str'\n"]
    pub unsafe fn ulStringAssignString(&self, str_: ULString, new_str: ULString) {
        (self.ulStringAssignString)(str_, new_str)
    }
    #[doc = "\n Replaces the contents of 'str' with the contents of a C-string.\n"]
    pub unsafe fn ulStringAssignCString(
        &self,
        str_: ULString,
        c_str: *const ::std::os::raw::c_char,
    ) {
        (self.ulStringAssignCString)(str_, c_str)
    }
    #[doc = "\n Create a font file from an on-disk file path.\n\n @note  The file path should already exist.\n"]
    pub unsafe fn ulFontFileCreateFromFilePath(&self, file_path: ULString) -> ULFontFile {
        (self.ulFontFileCreateFromFilePath)(file_path)
    }
    #[doc = "\n Create a font file from an in-memory buffer.\n"]
    pub unsafe fn ulFontFileCreateFromBuffer(&self, buffer: ULBuffer) -> ULFontFile {
        (self.ulFontFileCreateFromBuffer)(buffer)
    }
    #[doc = "\n Destroy font file\n"]
    pub unsafe fn ulDestroyFontFile(&self, font_file: ULFontFile) {
        (self.ulDestroyFontFile)(font_file)
    }
    #[doc = "\n Whether or not a ULRect is empty (all members equal to 0)\n"]
    pub unsafe fn ulRectIsEmpty(&self, rect: ULRect) -> bool {
        (self.ulRectIsEmpty)(rect)
    }
    #[doc = "\n Create an empty ULRect (all members equal to 0)\n"]
    pub unsafe fn ulRectMakeEmpty(&self) -> ULRect {
        (self.ulRectMakeEmpty)()
    }
    #[doc = "\n Whether or not a ULIntRect is empty (all members equal to 0)\n"]
    pub unsafe fn ulIntRectIsEmpty(&self, rect: ULIntRect) -> bool {
        (self.ulIntRectIsEmpty)(rect)
    }
    #[doc = "\n Create an empty ULIntRect (all members equal to 0)\n"]
    pub unsafe fn ulIntRectMakeEmpty(&self) -> ULIntRect {
        (self.ulIntRectMakeEmpty)()
    }
    #[doc = "\n Sets up an orthographic projection matrix with a certain viewport width and height, multiplies\n it by 'transform', and returns the result.\n\n This should be used to calculate the model-view projection matrix for the vertex shaders using\n the current ULGPUState.\n\n The 'flip_y' can be optionally used to flip the Y coordinate-space. (Usually flip_y == true for\n OpenGL)\n"]
    pub unsafe fn ulApplyProjection(
        &self,
        transform: ULMatrix4x4,
        viewport_width: f32,
        viewport_height: f32,
        flip_y: bool,
    ) -> ULMatrix4x4 {
        (self.ulApplyProjection)(transform, viewport_width, viewport_height, flip_y)
    }
    #[doc = "\n Create an image source from a GPU texture with optional backing bitmap.\n\n @param  width  The width of the image in pixels (used for layout).\n\n @param  height  The height of the image in pixels (used for layout).\n\n @param  texture_id  The GPU texture identifier to bind when drawing the quad for this image.\n                     This should be non-zero and obtained from ULGPUDriver::next_texture_id.\n\n @param  texture_uv  The UV coordinates of the texture.\n\n @param  bitmap  Optional backing bitmap for this image source. This is used when drawing\n                 the image using the CPU renderer or when pixel data is needed for other\n                 purposes. You should update this bitmap when the texture changes.\n\n @return  A new image source instance.\n"]
    pub unsafe fn ulCreateImageSourceFromTexture(
        &self,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        texture_id: ::std::os::raw::c_uint,
        texture_uv: ULRect,
        bitmap: ULBitmap,
    ) -> ULImageSource {
        (self.ulCreateImageSourceFromTexture)(width, height, texture_id, texture_uv, bitmap)
    }
    #[doc = "\n Create an image source from a bitmap.\n\n @param  bitmap  The backing bitmap for this image source.\n\n @return  A new image source instance.\n"]
    pub unsafe fn ulCreateImageSourceFromBitmap(&self, bitmap: ULBitmap) -> ULImageSource {
        (self.ulCreateImageSourceFromBitmap)(bitmap)
    }
    #[doc = "\n Destroy an image source.\n\n @param  image_source  The image source to destroy.\n"]
    pub unsafe fn ulDestroyImageSource(&self, image_source: ULImageSource) {
        (self.ulDestroyImageSource)(image_source)
    }
    #[doc = "\n Invalidate the image source, notifying the library that the image has changed\n and should be redrawn.\n"]
    pub unsafe fn ulImageSourceInvalidate(&self, image_source: ULImageSource) {
        (self.ulImageSourceInvalidate)(image_source)
    }
    #[doc = "\n Add an image source to the provider.\n\n @param  id  The identifier of the image source.\n\n @param  image_source  The image source to add.\n"]
    pub unsafe fn ulImageSourceProviderAddImageSource(
        &self,
        id: ULString,
        image_source: ULImageSource,
    ) {
        (self.ulImageSourceProviderAddImageSource)(id, image_source)
    }
    #[doc = "\n Remove an image source from the provider.\n\n @param  id  The identifier of the image source.\n"]
    pub unsafe fn ulImageSourceProviderRemoveImageSource(&self, id: ULString) {
        (self.ulImageSourceProviderRemoveImageSource)(id)
    }
    #[doc = "\n Create a key event, see KeyEvent in the C++ API for help with the parameters.\n"]
    pub unsafe fn ulCreateKeyEvent(
        &self,
        type_: ULKeyEventType,
        modifiers: ::std::os::raw::c_uint,
        virtual_key_code: ::std::os::raw::c_int,
        native_key_code: ::std::os::raw::c_int,
        text: ULString,
        unmodified_text: ULString,
        is_keypad: bool,
        is_auto_repeat: bool,
        is_system_key: bool,
    ) -> ULKeyEvent {
        (self.ulCreateKeyEvent)(
            type_,
            modifiers,
            virtual_key_code,
            native_key_code,
            text,
            unmodified_text,
            is_keypad,
            is_auto_repeat,
            is_system_key,
        )
    }
    #[doc = "\n Destroy a key event.\n"]
    pub unsafe fn ulDestroyKeyEvent(&self, evt: ULKeyEvent) {
        (self.ulDestroyKeyEvent)(evt)
    }
    #[doc = "\n Create a mouse event, see MouseEvent in the C++ API for help using this function.\n"]
    pub unsafe fn ulCreateMouseEvent(
        &self,
        type_: ULMouseEventType,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        button: ULMouseButton,
    ) -> ULMouseEvent {
        (self.ulCreateMouseEvent)(type_, x, y, button)
    }
    #[doc = "\n Destroy a mouse event.\n"]
    pub unsafe fn ulDestroyMouseEvent(&self, evt: ULMouseEvent) {
        (self.ulDestroyMouseEvent)(evt)
    }
    #[doc = "\n Width (in pixels).\n"]
    pub unsafe fn ulSurfaceGetWidth(&self, surface: ULSurface) -> ::std::os::raw::c_uint {
        (self.ulSurfaceGetWidth)(surface)
    }
    #[doc = "\n Height (in pixels).\n"]
    pub unsafe fn ulSurfaceGetHeight(&self, surface: ULSurface) -> ::std::os::raw::c_uint {
        (self.ulSurfaceGetHeight)(surface)
    }
    #[doc = "\n Number of bytes between rows (usually width * 4)\n"]
    pub unsafe fn ulSurfaceGetRowBytes(&self, surface: ULSurface) -> ::std::os::raw::c_uint {
        (self.ulSurfaceGetRowBytes)(surface)
    }
    #[doc = "\n Size in bytes.\n"]
    pub unsafe fn ulSurfaceGetSize(&self, surface: ULSurface) -> usize {
        (self.ulSurfaceGetSize)(surface)
    }
    #[doc = "\n Lock the pixel buffer and get a pointer to the beginning of the data for reading/writing.\n\n Native pixel format is premultiplied BGRA 32-bit (8 bits per channel).\n"]
    pub unsafe fn ulSurfaceLockPixels(&self, surface: ULSurface) -> *mut ::std::os::raw::c_void {
        (self.ulSurfaceLockPixels)(surface)
    }
    #[doc = "\n Unlock the pixel buffer.\n"]
    pub unsafe fn ulSurfaceUnlockPixels(&self, surface: ULSurface) {
        (self.ulSurfaceUnlockPixels)(surface)
    }
    #[doc = "\n Resize the pixel buffer to a certain width and height (both in pixels).\n\n This should never be called while pixels are locked.\n"]
    pub unsafe fn ulSurfaceResize(
        &self,
        surface: ULSurface,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) {
        (self.ulSurfaceResize)(surface, width, height)
    }
    #[doc = "\n Set the dirty bounds to a certain value.\n\n This is called after the Renderer paints to an area of the pixel buffer. (The new value will be\n joined with the existing dirty_bounds())\n"]
    pub unsafe fn ulSurfaceSetDirtyBounds(&self, surface: ULSurface, bounds: ULIntRect) {
        (self.ulSurfaceSetDirtyBounds)(surface, bounds)
    }
    #[doc = "\n Get the dirty bounds.\n\n This value can be used to determine which portion of the pixel buffer has been updated since the\n last call to ulSurfaceClearDirtyBounds().\n\n The general algorithm to determine if a Surface needs display is:\n <pre>\n   if (!ulIntRectIsEmpty(ulSurfaceGetDirtyBounds(surface))) {\n       // Surface pixels are dirty and needs display.\n       // Cast Surface to native Surface and use it here (pseudo code)\n       DisplaySurface(surface);\n\n       // Once you're done, clear the dirty bounds:\n       ulSurfaceClearDirtyBounds(surface);\n  }\n  </pre>\n"]
    pub unsafe fn ulSurfaceGetDirtyBounds(&self, surface: ULSurface) -> ULIntRect {
        (self.ulSurfaceGetDirtyBounds)(surface)
    }
    #[doc = "\n Clear the dirty bounds.\n\n You should call this after you're done displaying the Surface.\n"]
    pub unsafe fn ulSurfaceClearDirtyBounds(&self, surface: ULSurface) {
        (self.ulSurfaceClearDirtyBounds)(surface)
    }
    #[doc = "\n Get the underlying user data pointer (this is only valid if you have set a custom surface\n implementation via ulPlatformSetSurfaceDefinition).\n\n This will return nullptr if this surface is the default ULBitmapSurface.\n"]
    pub unsafe fn ulSurfaceGetUserData(&self, surface: ULSurface) -> *mut ::std::os::raw::c_void {
        (self.ulSurfaceGetUserData)(surface)
    }
    #[doc = "\n Get the underlying Bitmap from the default Surface.\n\n @note  Do not call ulDestroyBitmap() on the returned value, it is owned by the surface.\n"]
    pub unsafe fn ulBitmapSurfaceGetBitmap(&self, surface: ULBitmapSurface) -> ULBitmap {
        (self.ulBitmapSurfaceGetBitmap)(surface)
    }
    #[doc = "\n Set a custom Logger implementation.\n\n This is used to log debug messages to the console or to a log file.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @note  ulCreateApp() will use the default logger if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default logger by calling ulEnableDefaultLogger() (@see <AppCore/CAPI.h>)\n"]
    pub unsafe fn ulPlatformSetLogger(&self, logger: ULLogger) {
        (self.ulPlatformSetLogger)(logger)
    }
    #[doc = "\n Set a custom FileSystem implementation.\n\n The library uses this to load all file URLs (eg, <file:///page.html>).\n\n You can provide the library with your own FileSystem implementation so that file assets are\n loaded from your own pipeline.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n\n @warning This is required to be defined before calling ulCreateRenderer()\n\n @note  ulCreateApp() will use the default platform file system if you never call this.\n\n @note  If you're not using ulCreateApp(), (eg, using ulCreateRenderer()) you can still use the\n        default platform file system by calling ulEnablePlatformFileSystem()'\n        (@see <AppCore/CAPI.h>)\n"]
    pub unsafe fn ulPlatformSetFileSystem(&self, file_system: ULFileSystem) {
        (self.ulPlatformSetFileSystem)(file_system)
    }
    #[doc = "\n Set a custom Surface implementation.\n\n This can be used to wrap a platform-specific GPU texture, Windows DIB, macOS CGImage, or any\n other pixel buffer target for display on screen.\n\n By default, the library uses a bitmap surface for all surfaces but you can override this by\n providing your own surface definition here.\n\n You should call this before ulCreateRenderer() or ulCreateApp().\n"]
    pub unsafe fn ulPlatformSetSurfaceDefinition(&self, surface_definition: ULSurfaceDefinition) {
        (self.ulPlatformSetSurfaceDefinition)(surface_definition)
    }
    #[doc = "\n Set a custom GPUDriver implementation.\n\n This should be used if you have enabled the GPU renderer in the Config and are using\n ulCreateRenderer() (which does not provide its own GPUDriver implementation).\n\n The GPUDriver interface is used by the library to dispatch GPU calls to your native GPU context\n (eg, D3D11, Metal, OpenGL, Vulkan, etc.) There are reference implementations for this interface\n in the AppCore repo.\n\n You should call this before ulCreateRenderer().\n"]
    pub unsafe fn ulPlatformSetGPUDriver(&self, gpu_driver: ULGPUDriver) {
        (self.ulPlatformSetGPUDriver)(gpu_driver)
    }
    #[doc = "\n Set a custom Clipboard implementation.\n\n This should be used if you are using ulCreateRenderer() (which does not provide its own\n clipboard implementation).\n\n The Clipboard interface is used by the library to make calls to the system's native clipboard\n (eg, cut, copy, paste).\n\n You should call this before ulCreateRenderer().\n"]
    pub unsafe fn ulPlatformSetClipboard(&self, clipboard: ULClipboard) {
        (self.ulPlatformSetClipboard)(clipboard)
    }
    #[doc = "\n Create the core renderer singleton for the library.\n\n You should set up the Platform singleton (see CAPI_Platform.h) before calling this function.\n\n @note You do not need to the call this if you're using ulCreateApp() from AppCore.\n\n \\parblock\n @warning You'll need to define a ULFontLoader and ULFileSystem within the Platform singleton\n         or else this call will fail.\n \\endparblock\n\n \\parblock\n @warning You should only create one Renderer during the lifetime of your program.\n \\endparblock\n\n @param  config  The configuration to use for the renderer.\n\n @return  Returns the new renderer instance.\n"]
    pub unsafe fn ulCreateRenderer(&self, config: ULConfig) -> ULRenderer {
        (self.ulCreateRenderer)(config)
    }
    #[doc = "\n Destroy the renderer.\n\n @param renderer  The renderer instance to destroy.\n"]
    pub unsafe fn ulDestroyRenderer(&self, renderer: ULRenderer) {
        (self.ulDestroyRenderer)(renderer)
    }
    #[doc = "\n Update timers and dispatch internal callbacks (JavaScript and network).\n\n @param  renderer  The active renderer instance.\n"]
    pub unsafe fn ulUpdate(&self, renderer: ULRenderer) {
        (self.ulUpdate)(renderer)
    }
    #[doc = "\n Notify the renderer that a display has refreshed (you should call this after vsync).\n\n This updates animations, smooth scroll, and window.requestAnimationFrame() for all Views\n matching the display id.\n\n @param  renderer  The active renderer instance.\n\n @param  display_id  The display ID to refresh (0 by default).\n"]
    pub unsafe fn ulRefreshDisplay(
        &self,
        renderer: ULRenderer,
        display_id: ::std::os::raw::c_uint,
    ) {
        (self.ulRefreshDisplay)(renderer, display_id)
    }
    #[doc = "\n Render all active Views to their respective surfaces and render targets.\n\n @param  renderer  The active renderer instance.\n"]
    pub unsafe fn ulRender(&self, renderer: ULRenderer) {
        (self.ulRender)(renderer)
    }
    #[doc = "\n Attempt to release as much memory as possible. Don't call this from any callbacks or driver\n code.\n\n @param  renderer  The active renderer instance.\n"]
    pub unsafe fn ulPurgeMemory(&self, renderer: ULRenderer) {
        (self.ulPurgeMemory)(renderer)
    }
    #[doc = "\n Print detailed memory usage statistics to the log. (@see ulPlatformSetLogger)\n\n @param  renderer  The active renderer instance.\n"]
    pub unsafe fn ulLogMemoryUsage(&self, renderer: ULRenderer) {
        (self.ulLogMemoryUsage)(renderer)
    }
    #[doc = "\n Start the remote inspector server.\n\n While the remote inspector is active, Views that are loaded into this renderer\n will be able to be remotely inspected from another Ultralight instance either locally\n (another app on same machine) or remotely (over the network) by navigating a View to:\n\n \\code\n   inspector://<ADDRESS>:<PORT>\n \\endcode\n\n @param renderer  The active renderer instance.\n\n @param address   The address for the server to listen on (eg, \"127.0.0.1\")\n\n @param port      The port for the server to listen on (eg, 9222)\n\n @return  Returns whether the server started successfully or not.\n"]
    pub unsafe fn ulStartRemoteInspectorServer(
        &self,
        renderer: ULRenderer,
        address: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    ) -> bool {
        (self.ulStartRemoteInspectorServer)(renderer, address, port)
    }
    #[doc = "\n Describe the details of a gamepad, to be used with ulFireGamepadEvent and related\n events below. This can be called multiple times with the same index if the details change.\n\n @param  renderer  The active renderer instance.\n\n @param  index   The unique index (or \"connection slot\") of the gamepad. For example,\n                 controller #1 would be \"1\", controller #2 would be \"2\" and so on.\n\n @param  id      A string ID representing the device, this will be made available\n                 in JavaScript as gamepad.id\n\n @param  axis_count  The number of axes on the device.\n\n @param  button_count  The number of buttons on the device.\n"]
    pub unsafe fn ulSetGamepadDetails(
        &self,
        renderer: ULRenderer,
        index: ::std::os::raw::c_uint,
        id: ULString,
        axis_count: ::std::os::raw::c_uint,
        button_count: ::std::os::raw::c_uint,
    ) {
        (self.ulSetGamepadDetails)(renderer, index, id, axis_count, button_count)
    }
    #[doc = "\n Fire a gamepad event (connection / disconnection).\n\n @note  The gamepad should first be described via ulSetGamepadDetails before calling this\n        function.\n\n @param renderer  The active renderer instance.\n\n @param evt       The event to fire.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad>\n"]
    pub unsafe fn ulFireGamepadEvent(&self, renderer: ULRenderer, evt: ULGamepadEvent) {
        (self.ulFireGamepadEvent)(renderer, evt)
    }
    #[doc = "\n Fire a gamepad axis event (to be called when an axis value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @param renderer  The active renderer instance.\n\n @param evt       The event to fire.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/axes>\n"]
    pub unsafe fn ulFireGamepadAxisEvent(&self, renderer: ULRenderer, evt: ULGamepadAxisEvent) {
        (self.ulFireGamepadAxisEvent)(renderer, evt)
    }
    #[doc = "\n Fire a gamepad button event (to be called when a button value is changed).\n\n @note  The gamepad should be connected via a previous call to ulFireGamepadEvent.\n\n @param renderer  The active renderer instance.\n\n @param evt       The event to fire.\n\n @see <https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/buttons>\n"]
    pub unsafe fn ulFireGamepadButtonEvent(&self, renderer: ULRenderer, evt: ULGamepadButtonEvent) {
        (self.ulFireGamepadButtonEvent)(renderer, evt)
    }
    #[doc = "\n Create a scroll event, see ScrollEvent in the C++ API for help using this function.\n"]
    pub unsafe fn ulCreateScrollEvent(
        &self,
        type_: ULScrollEventType,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> ULScrollEvent {
        (self.ulCreateScrollEvent)(type_, delta_x, delta_y)
    }
    #[doc = "\n Destroy a scroll event.\n"]
    pub unsafe fn ulDestroyScrollEvent(&self, evt: ULScrollEvent) {
        (self.ulDestroyScrollEvent)(evt)
    }
    #[doc = "\n Create a gamepad event, see GamepadEvent for help using this function.\n"]
    pub unsafe fn ulCreateGamepadEvent(
        &self,
        index: ::std::os::raw::c_uint,
        type_: ULGamepadEventType,
    ) -> ULGamepadEvent {
        (self.ulCreateGamepadEvent)(index, type_)
    }
    #[doc = "\n Destroy a gamepad event.\n"]
    pub unsafe fn ulDestroyGamepadEvent(&self, evt: ULGamepadEvent) {
        (self.ulDestroyGamepadEvent)(evt)
    }
    #[doc = "\n Create a gamepad axis event, see GamepadAxisEvent for help using this function.\n"]
    pub unsafe fn ulCreateGamepadAxisEvent(
        &self,
        index: ::std::os::raw::c_uint,
        axis_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadAxisEvent {
        (self.ulCreateGamepadAxisEvent)(index, axis_index, value)
    }
    #[doc = "\n Destroy a gamepad axis event.\n"]
    pub unsafe fn ulDestroyGamepadAxisEvent(&self, evt: ULGamepadAxisEvent) {
        (self.ulDestroyGamepadAxisEvent)(evt)
    }
    #[doc = "\n Create a gamepad button event, see GamepadButtonEvent for help using this function.\n"]
    pub unsafe fn ulCreateGamepadButtonEvent(
        &self,
        index: ::std::os::raw::c_uint,
        button_index: ::std::os::raw::c_uint,
        value: f64,
    ) -> ULGamepadButtonEvent {
        (self.ulCreateGamepadButtonEvent)(index, button_index, value)
    }
    #[doc = "\n Destroy a gamepad button event.\n"]
    pub unsafe fn ulDestroyGamepadButtonEvent(&self, evt: ULGamepadButtonEvent) {
        (self.ulDestroyGamepadButtonEvent)(evt)
    }
    #[doc = "\n Create a Session to store local data in (such as cookies, local storage, application cache,\n indexed db, etc).\n"]
    pub unsafe fn ulCreateSession(
        &self,
        renderer: ULRenderer,
        is_persistent: bool,
        name: ULString,
    ) -> ULSession {
        (self.ulCreateSession)(renderer, is_persistent, name)
    }
    #[doc = "\n Destroy a Session.\n"]
    pub unsafe fn ulDestroySession(&self, session: ULSession) {
        (self.ulDestroySession)(session)
    }
    #[doc = "\n Get the default session (persistent session named \"default\").\n\n @note  This session is owned by the Renderer, you shouldn't destroy it.\n"]
    pub unsafe fn ulDefaultSession(&self, renderer: ULRenderer) -> ULSession {
        (self.ulDefaultSession)(renderer)
    }
    #[doc = "\n Whether or not is persistent (backed to disk).\n"]
    pub unsafe fn ulSessionIsPersistent(&self, session: ULSession) -> bool {
        (self.ulSessionIsPersistent)(session)
    }
    #[doc = "\n Unique name identifying the session (used for unique disk path).\n"]
    pub unsafe fn ulSessionGetName(&self, session: ULSession) -> ULString {
        (self.ulSessionGetName)(session)
    }
    #[doc = "\n Unique numeric Id for the session.\n"]
    pub unsafe fn ulSessionGetId(&self, session: ULSession) -> ::std::os::raw::c_ulonglong {
        (self.ulSessionGetId)(session)
    }
    #[doc = "\n The disk path to write to (used by persistent sessions only).\n"]
    pub unsafe fn ulSessionGetDiskPath(&self, session: ULSession) -> ULString {
        (self.ulSessionGetDiskPath)(session)
    }
    #[doc = "\n Create view configuration with default values (see <Ultralight/platform/View.h>).\n"]
    pub unsafe fn ulCreateViewConfig(&self) -> ULViewConfig {
        (self.ulCreateViewConfig)()
    }
    #[doc = "\n Destroy view configuration.\n"]
    pub unsafe fn ulDestroyViewConfig(&self, config: ULViewConfig) {
        (self.ulDestroyViewConfig)(config)
    }
    #[doc = "\n Set a user-generated id of the display (monitor, TV, or screen) that the View will be shown on.\n\n Animations are driven based on the physical refresh rate of the display. Multiple Views can\n share the same display.\n\n\n @note This is automatically managed for you when ulCreateApp() is used.\n\n @see ulRefreshDisplay()\n"]
    pub unsafe fn ulViewConfigSetDisplayId(
        &self,
        config: ULViewConfig,
        display_id: ::std::os::raw::c_uint,
    ) {
        (self.ulViewConfigSetDisplayId)(config, display_id)
    }
    #[doc = "\n Set whether to render using the GPU renderer (accelerated) or the CPU renderer (unaccelerated).\n\n This option is only valid if you're managing the Renderer yourself (eg, you've previously\n called ulCreateRenderer() instead of ulCreateApp()).\n\n When true, the View will be rendered to an offscreen GPU texture using the GPU driver set in\n ulPlatformSetGPUDriver(). You can fetch details for the texture via ulViewGetRenderTarget().\n\n When false (the default), the View will be rendered to an offscreen pixel buffer using the\n multithreaded CPU renderer. This pixel buffer can optionally be provided by the user--\n for more info see ulViewGetSurface().\n"]
    pub unsafe fn ulViewConfigSetIsAccelerated(&self, config: ULViewConfig, is_accelerated: bool) {
        (self.ulViewConfigSetIsAccelerated)(config, is_accelerated)
    }
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub unsafe fn ulViewConfigSetIsTransparent(&self, config: ULViewConfig, is_transparent: bool) {
        (self.ulViewConfigSetIsTransparent)(config, is_transparent)
    }
    #[doc = "\n Set the initial device scale, ie. the amount to scale page units to screen pixels. This should be\n set to the scaling factor of the device that the View is displayed on. (Default = 1.0)\n\n @note 1.0 is equal to 100% zoom (no scaling), 2.0 is equal to 200% zoom (2x scaling)\n"]
    pub unsafe fn ulViewConfigSetInitialDeviceScale(
        &self,
        config: ULViewConfig,
        initial_device_scale: f64,
    ) {
        (self.ulViewConfigSetInitialDeviceScale)(config, initial_device_scale)
    }
    #[doc = "\n Set whether or not the View should initially have input focus. (Default = True)\n"]
    pub unsafe fn ulViewConfigSetInitialFocus(&self, config: ULViewConfig, is_focused: bool) {
        (self.ulViewConfigSetInitialFocus)(config, is_focused)
    }
    #[doc = "\n Set whether images should be enabled (Default = True).\n"]
    pub unsafe fn ulViewConfigSetEnableImages(&self, config: ULViewConfig, enabled: bool) {
        (self.ulViewConfigSetEnableImages)(config, enabled)
    }
    #[doc = "\n Set whether JavaScript should be enabled (Default = True).\n"]
    pub unsafe fn ulViewConfigSetEnableJavaScript(&self, config: ULViewConfig, enabled: bool) {
        (self.ulViewConfigSetEnableJavaScript)(config, enabled)
    }
    #[doc = "\n Set default font-family to use (Default = Times New Roman).\n"]
    pub unsafe fn ulViewConfigSetFontFamilyStandard(
        &self,
        config: ULViewConfig,
        font_name: ULString,
    ) {
        (self.ulViewConfigSetFontFamilyStandard)(config, font_name)
    }
    #[doc = "\n Set default font-family to use for fixed fonts, eg <pre> and <code>\n (Default = Courier New).\n"]
    pub unsafe fn ulViewConfigSetFontFamilyFixed(&self, config: ULViewConfig, font_name: ULString) {
        (self.ulViewConfigSetFontFamilyFixed)(config, font_name)
    }
    #[doc = "\n Set default font-family to use for serif fonts (Default = Times New Roman).\n"]
    pub unsafe fn ulViewConfigSetFontFamilySerif(&self, config: ULViewConfig, font_name: ULString) {
        (self.ulViewConfigSetFontFamilySerif)(config, font_name)
    }
    #[doc = "\n Set default font-family to use for sans-serif fonts (Default = Arial).\n"]
    pub unsafe fn ulViewConfigSetFontFamilySansSerif(
        &self,
        config: ULViewConfig,
        font_name: ULString,
    ) {
        (self.ulViewConfigSetFontFamilySansSerif)(config, font_name)
    }
    #[doc = "\n Set user agent string (See <Ultralight/platform/Config.h> for the default).\n"]
    pub unsafe fn ulViewConfigSetUserAgent(&self, config: ULViewConfig, agent_string: ULString) {
        (self.ulViewConfigSetUserAgent)(config, agent_string)
    }
    #[doc = "\n Create a View with certain size (in pixels).\n\n @note  You can pass null to 'session' to use the default session.\n"]
    pub unsafe fn ulCreateView(
        &self,
        renderer: ULRenderer,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        view_config: ULViewConfig,
        session: ULSession,
    ) -> ULView {
        (self.ulCreateView)(renderer, width, height, view_config, session)
    }
    #[doc = "\n Destroy a View.\n"]
    pub unsafe fn ulDestroyView(&self, view: ULView) {
        (self.ulDestroyView)(view)
    }
    #[doc = "\n Get current URL.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub unsafe fn ulViewGetURL(&self, view: ULView) -> ULString {
        (self.ulViewGetURL)(view)
    }
    #[doc = "\n Get current title.\n\n @note Don't destroy the returned string, it is owned by the View.\n"]
    pub unsafe fn ulViewGetTitle(&self, view: ULView) -> ULString {
        (self.ulViewGetTitle)(view)
    }
    #[doc = "\n Get the width, in pixels.\n"]
    pub unsafe fn ulViewGetWidth(&self, view: ULView) -> ::std::os::raw::c_uint {
        (self.ulViewGetWidth)(view)
    }
    #[doc = "\n Get the height, in pixels.\n"]
    pub unsafe fn ulViewGetHeight(&self, view: ULView) -> ::std::os::raw::c_uint {
        (self.ulViewGetHeight)(view)
    }
    pub unsafe fn ulViewGetDisplayId(&self, view: ULView) -> ::std::os::raw::c_uint {
        (self.ulViewGetDisplayId)(view)
    }
    #[doc = "\n Set the display id of the View.\n\n This should be called when the View is moved to another display.\n"]
    pub unsafe fn ulViewSetDisplayId(&self, view: ULView, display_id: ::std::os::raw::c_uint) {
        (self.ulViewSetDisplayId)(view, display_id)
    }
    #[doc = "\n Get the device scale, ie. the amount to scale page units to screen pixels.\n\n For example, a value of 1.0 is equivalent to 100% zoom. A value of 2.0 is 200% zoom.\n"]
    pub unsafe fn ulViewGetDeviceScale(&self, view: ULView) -> f64 {
        (self.ulViewGetDeviceScale)(view)
    }
    #[doc = "\n Set the device scale.\n"]
    pub unsafe fn ulViewSetDeviceScale(&self, view: ULView, scale: f64) {
        (self.ulViewSetDeviceScale)(view, scale)
    }
    #[doc = "\n Whether or not the View is GPU-accelerated. If this is false, the page will be rendered\n via the CPU renderer.\n"]
    pub unsafe fn ulViewIsAccelerated(&self, view: ULView) -> bool {
        (self.ulViewIsAccelerated)(view)
    }
    #[doc = "\n Whether or not the View supports transparent backgrounds.\n"]
    pub unsafe fn ulViewIsTransparent(&self, view: ULView) -> bool {
        (self.ulViewIsTransparent)(view)
    }
    #[doc = "\n Check if the main frame of the page is currrently loading.\n"]
    pub unsafe fn ulViewIsLoading(&self, view: ULView) -> bool {
        (self.ulViewIsLoading)(view)
    }
    #[doc = "\n Get the RenderTarget for the View.\n\n @note  Only valid if this View is GPU accelerated.\n\n        You can use this with your GPUDriver implementation to bind and display the\n        corresponding texture in your application.\n"]
    pub unsafe fn ulViewGetRenderTarget(&self, view: ULView) -> ULRenderTarget {
        (self.ulViewGetRenderTarget)(view)
    }
    #[doc = "\n Get the Surface for the View (native pixel buffer that the CPU renderer draws into).\n\n @note  This operation is only valid if you're managing the Renderer yourself (eg, you've\n        previously called ulCreateRenderer() instead of ulCreateApp()).\n\n        This function will return NULL if this View is GPU accelerated.\n\n        The default Surface is BitmapSurface but you can provide your own Surface implementation\n        via ulPlatformSetSurfaceDefinition.\n\n        When using the default Surface, you can retrieve the underlying bitmap by casting\n        ULSurface to ULBitmapSurface and calling ulBitmapSurfaceGetBitmap().\n"]
    pub unsafe fn ulViewGetSurface(&self, view: ULView) -> ULSurface {
        (self.ulViewGetSurface)(view)
    }
    #[doc = "\n Load a raw string of HTML.\n"]
    pub unsafe fn ulViewLoadHTML(&self, view: ULView, html_string: ULString) {
        (self.ulViewLoadHTML)(view, html_string)
    }
    #[doc = "\n Load a URL into main frame.\n"]
    pub unsafe fn ulViewLoadURL(&self, view: ULView, url_string: ULString) {
        (self.ulViewLoadURL)(view, url_string)
    }
    #[doc = "\n Resize view to a certain width and height (in pixels).\n"]
    pub unsafe fn ulViewResize(
        &self,
        view: ULView,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) {
        (self.ulViewResize)(view, width, height)
    }
    #[doc = "\n Acquire the page's JSContext for use with JavaScriptCore API.\n\n @note  This call locks the context for the current thread. You should call\n        ulViewUnlockJSContext() after using the context so other worker threads can modify\n        JavaScript state.\n\n @note  The lock is recusive, it's okay to call this multiple times as long as you call\n        ulViewUnlockJSContext() the same number of times.\n"]
    pub unsafe fn ulViewLockJSContext(&self, view: ULView) -> JSContextRef {
        (self.ulViewLockJSContext)(view)
    }
    #[doc = "\n Unlock the page's JSContext after a previous call to ulViewLockJSContext().\n"]
    pub unsafe fn ulViewUnlockJSContext(&self, view: ULView) {
        (self.ulViewUnlockJSContext)(view)
    }
    #[doc = "\n Evaluate a string of JavaScript and return result.\n\n @param  js_string  The string of JavaScript to evaluate.\n\n @param  exception  The address of a ULString to store a description of the last exception. Pass\n                    NULL to ignore this. Don't destroy the exception string returned, it's owned\n                    by the View.\n\n @note Don't destroy the returned string, it's owned by the View. This value is reset with every\n       call-- if you want to retain it you should copy the result to a new string via\n       ulCreateStringFromCopy().\n\n @note An example of using this API:\n       <pre>\n         ULString script = ulCreateString(\"1 + 1\");\n         ULString exception;\n         ULString result = ulViewEvaluateScript(view, script, &exception);\n         /* Use the result (\"2\") and exception description (if any) here. */\n         ulDestroyString(script);\n       </pre>\n"]
    pub unsafe fn ulViewEvaluateScript(
        &self,
        view: ULView,
        js_string: ULString,
        exception: *mut ULString,
    ) -> ULString {
        (self.ulViewEvaluateScript)(view, js_string, exception)
    }
    #[doc = "\n Check if can navigate backwards in history.\n"]
    pub unsafe fn ulViewCanGoBack(&self, view: ULView) -> bool {
        (self.ulViewCanGoBack)(view)
    }
    #[doc = "\n Check if can navigate forwards in history.\n"]
    pub unsafe fn ulViewCanGoForward(&self, view: ULView) -> bool {
        (self.ulViewCanGoForward)(view)
    }
    #[doc = "\n Navigate backwards in history.\n"]
    pub unsafe fn ulViewGoBack(&self, view: ULView) {
        (self.ulViewGoBack)(view)
    }
    #[doc = "\n Navigate forwards in history.\n"]
    pub unsafe fn ulViewGoForward(&self, view: ULView) {
        (self.ulViewGoForward)(view)
    }
    #[doc = "\n Navigate to arbitrary offset in history.\n"]
    pub unsafe fn ulViewGoToHistoryOffset(&self, view: ULView, offset: ::std::os::raw::c_int) {
        (self.ulViewGoToHistoryOffset)(view, offset)
    }
    #[doc = "\n Reload current page.\n"]
    pub unsafe fn ulViewReload(&self, view: ULView) {
        (self.ulViewReload)(view)
    }
    #[doc = "\n Stop all page loads.\n"]
    pub unsafe fn ulViewStop(&self, view: ULView) {
        (self.ulViewStop)(view)
    }
    #[doc = "\n Give focus to the View.\n\n You should call this to give visual indication that the View has input focus (changes active\n text selection colors, for example).\n"]
    pub unsafe fn ulViewFocus(&self, view: ULView) {
        (self.ulViewFocus)(view)
    }
    #[doc = "\n Remove focus from the View and unfocus any focused input elements.\n\n You should call this to give visual indication that the View has lost input focus.\n"]
    pub unsafe fn ulViewUnfocus(&self, view: ULView) {
        (self.ulViewUnfocus)(view)
    }
    #[doc = "\n Whether or not the View has focus.\n"]
    pub unsafe fn ulViewHasFocus(&self, view: ULView) -> bool {
        (self.ulViewHasFocus)(view)
    }
    #[doc = "\n Whether or not the View has an input element with visible keyboard focus (indicated by a\n blinking caret).\n\n You can use this to decide whether or not the View should consume keyboard input events (useful\n in games with mixed UI and key handling).\n"]
    pub unsafe fn ulViewHasInputFocus(&self, view: ULView) -> bool {
        (self.ulViewHasInputFocus)(view)
    }
    #[doc = "\n Fire a keyboard event.\n"]
    pub unsafe fn ulViewFireKeyEvent(&self, view: ULView, key_event: ULKeyEvent) {
        (self.ulViewFireKeyEvent)(view, key_event)
    }
    #[doc = "\n Fire a mouse event.\n"]
    pub unsafe fn ulViewFireMouseEvent(&self, view: ULView, mouse_event: ULMouseEvent) {
        (self.ulViewFireMouseEvent)(view, mouse_event)
    }
    #[doc = "\n Fire a scroll event.\n"]
    pub unsafe fn ulViewFireScrollEvent(&self, view: ULView, scroll_event: ULScrollEvent) {
        (self.ulViewFireScrollEvent)(view, scroll_event)
    }
    #[doc = "\n Set callback for when the page title changes.\n"]
    pub unsafe fn ulViewSetChangeTitleCallback(
        &self,
        view: ULView,
        callback: ULChangeTitleCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetChangeTitleCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the page URL changes.\n"]
    pub unsafe fn ulViewSetChangeURLCallback(
        &self,
        view: ULView,
        callback: ULChangeURLCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetChangeURLCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the tooltip changes (usually result of a mouse hover).\n"]
    pub unsafe fn ulViewSetChangeTooltipCallback(
        &self,
        view: ULView,
        callback: ULChangeTooltipCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetChangeTooltipCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the mouse cursor changes.\n"]
    pub unsafe fn ulViewSetChangeCursorCallback(
        &self,
        view: ULView,
        callback: ULChangeCursorCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetChangeCursorCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when a message is added to the console (useful for JavaScript / network errors\n and debugging).\n"]
    pub unsafe fn ulViewSetAddConsoleMessageCallback(
        &self,
        view: ULView,
        callback: ULAddConsoleMessageCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetAddConsoleMessageCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the page wants to create a new View.\n\n This is usually the result of a user clicking a link with target=\"_blank\" or by JavaScript\n calling window.open(url).\n\n To allow creation of these new Views, you should create a new View in this callback, resize it\n to your container, and return it. You are responsible for displaying the returned View.\n\n You should return NULL if you want to block the action.\n"]
    pub unsafe fn ulViewSetCreateChildViewCallback(
        &self,
        view: ULView,
        callback: ULCreateChildViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetCreateChildViewCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the page wants to create a new View to display the local inspector in.\n\n You should create a new View in this callback, resize it to your\n container, and return it. You are responsible for displaying the returned View.\n"]
    pub unsafe fn ulViewSetCreateInspectorViewCallback(
        &self,
        view: ULView,
        callback: ULCreateInspectorViewCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetCreateInspectorViewCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the page begins loading a new URL into a frame.\n"]
    pub unsafe fn ulViewSetBeginLoadingCallback(
        &self,
        view: ULView,
        callback: ULBeginLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetBeginLoadingCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the page finishes loading a URL into a frame.\n"]
    pub unsafe fn ulViewSetFinishLoadingCallback(
        &self,
        view: ULView,
        callback: ULFinishLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetFinishLoadingCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when an error occurs while loading a URL into a frame.\n"]
    pub unsafe fn ulViewSetFailLoadingCallback(
        &self,
        view: ULView,
        callback: ULFailLoadingCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetFailLoadingCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the JavaScript window object is reset for a new page load.\n\n This is called before any scripts are executed on the page and is the earliest time to setup any\n initial JavaScript state or bindings.\n\n The document is not guaranteed to be loaded/parsed at this point. If you need to make any\n JavaScript calls that are dependent on DOM elements or scripts on the page, use DOMReady\n instead.\n\n The window object is lazily initialized (this will not be called on pages with no scripts).\n"]
    pub unsafe fn ulViewSetWindowObjectReadyCallback(
        &self,
        view: ULView,
        callback: ULWindowObjectReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetWindowObjectReadyCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when all JavaScript has been parsed and the document is ready.\n\n This is the best time to make any JavaScript calls that are dependent on DOM elements or scripts\n on the page.\n"]
    pub unsafe fn ulViewSetDOMReadyCallback(
        &self,
        view: ULView,
        callback: ULDOMReadyCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetDOMReadyCallback)(view, callback, user_data)
    }
    #[doc = "\n Set callback for when the history (back/forward state) is modified.\n"]
    pub unsafe fn ulViewSetUpdateHistoryCallback(
        &self,
        view: ULView,
        callback: ULUpdateHistoryCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) {
        (self.ulViewSetUpdateHistoryCallback)(view, callback, user_data)
    }
    #[doc = "\n Set whether or not a view should be repainted during the next call to ulRender.\n\n @note  This flag is automatically set whenever the page content changes but you can set it\n        directly in case you need to force a repaint.\n"]
    pub unsafe fn ulViewSetNeedsPaint(&self, view: ULView, needs_paint: bool) {
        (self.ulViewSetNeedsPaint)(view, needs_paint)
    }
    #[doc = "\n Whether or not a view should be painted during the next call to ulRender.\n"]
    pub unsafe fn ulViewGetNeedsPaint(&self, view: ULView) -> bool {
        (self.ulViewGetNeedsPaint)(view)
    }
    #[doc = "\n Create an Inspector View to inspect / debug this View locally.\n\n This will only succeed if you have the inspector assets in your filesystem-- the inspector\n will look for file:///inspector/Main.html when it first loads.\n\n You must handle ulViewSetCreateInspectorViewCallback so that the library has a View to display\n the inspector in. This function will call the callback only if an inspector view is not\n currently active.\n"]
    pub unsafe fn ulViewCreateLocalInspectorView(&self, view: ULView) {
        (self.ulViewCreateLocalInspectorView)(view)
    }
}
