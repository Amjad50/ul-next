/* automatically generated by rust-bindgen 0.70.1 */

pub const JSC_OBJC_API_ENABLED: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContextGroup {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextGroupRef A group that associates JavaScript contexts with one another. Contexts in the same group may share and exchange JavaScript objects."]
pub type JSContextGroupRef = *const OpaqueJSContextGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSContext {
    _unused: [u8; 0],
}
#[doc = " @typedef JSContextRef A JavaScript execution context. Holds the global object and other execution state."]
pub type JSContextRef = *const OpaqueJSContext;
#[doc = " @typedef JSGlobalContextRef A global JavaScript execution context. A JSGlobalContext is a JSContext."]
pub type JSGlobalContextRef = *mut OpaqueJSContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSString {
    _unused: [u8; 0],
}
#[doc = " @typedef JSStringRef A UTF16 character buffer. The fundamental string representation in JavaScript."]
pub type JSStringRef = *mut OpaqueJSString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSClass {
    _unused: [u8; 0],
}
#[doc = " @typedef JSClassRef A JavaScript class. Used with JSObjectMake to construct objects with custom behavior."]
pub type JSClassRef = *mut OpaqueJSClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameArray {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameArrayRef An array of JavaScript property names."]
pub type JSPropertyNameArrayRef = *mut OpaqueJSPropertyNameArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSPropertyNameAccumulator {
    _unused: [u8; 0],
}
#[doc = " @typedef JSPropertyNameAccumulatorRef An ordered set used to collect the names of a JavaScript object's properties."]
pub type JSPropertyNameAccumulatorRef = *mut OpaqueJSPropertyNameAccumulator;
#[doc = " @typedef JSTypedArrayBytesDeallocator A function used to deallocate bytes passed to a Typed Array constructor. The function should take two arguments. The first is a pointer to the bytes that were originally passed to the Typed Array constructor. The second is a pointer to additional information desired at the time the bytes are to be freed."]
pub type JSTypedArrayBytesDeallocator = ::std::option::Option<
    unsafe extern "C" fn(
        bytes: *mut ::std::os::raw::c_void,
        deallocatorContext: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueJSValue {
    _unused: [u8; 0],
}
#[doc = " @typedef JSValueRef A JavaScript value. The base type for all JavaScript values, and polymorphic functions on them."]
pub type JSValueRef = *const OpaqueJSValue;
#[doc = " @typedef JSObjectRef A JavaScript object. A JSObject is a JSValue."]
pub type JSObjectRef = *mut OpaqueJSValue;
pub const JSType_kJSTypeUndefined: JSType = 0;
pub const JSType_kJSTypeNull: JSType = 1;
pub const JSType_kJSTypeBoolean: JSType = 2;
pub const JSType_kJSTypeNumber: JSType = 3;
pub const JSType_kJSTypeString: JSType = 4;
pub const JSType_kJSTypeObject: JSType = 5;
pub const JSType_kJSTypeSymbol: JSType = 6;
#[doc = "@enum JSType\n@abstract     A constant identifying the type of a JSValue.\n@constant     kJSTypeUndefined  The unique undefined value.\n@constant     kJSTypeNull       The unique null value.\n@constant     kJSTypeBoolean    A primitive boolean value, one of true or false.\n@constant     kJSTypeNumber     A primitive number value.\n@constant     kJSTypeString     A primitive string value.\n@constant     kJSTypeObject     An object value (meaning that this JSValueRef is a JSObjectRef).\n@constant     kJSTypeSymbol     A primitive symbol value."]
pub type JSType = ::std::os::raw::c_uint;
pub const JSTypedArrayType_kJSTypedArrayTypeInt8Array: JSTypedArrayType = 0;
pub const JSTypedArrayType_kJSTypedArrayTypeInt16Array: JSTypedArrayType = 1;
pub const JSTypedArrayType_kJSTypedArrayTypeInt32Array: JSTypedArrayType = 2;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8Array: JSTypedArrayType = 3;
pub const JSTypedArrayType_kJSTypedArrayTypeUint8ClampedArray: JSTypedArrayType = 4;
pub const JSTypedArrayType_kJSTypedArrayTypeUint16Array: JSTypedArrayType = 5;
pub const JSTypedArrayType_kJSTypedArrayTypeUint32Array: JSTypedArrayType = 6;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat32Array: JSTypedArrayType = 7;
pub const JSTypedArrayType_kJSTypedArrayTypeFloat64Array: JSTypedArrayType = 8;
pub const JSTypedArrayType_kJSTypedArrayTypeArrayBuffer: JSTypedArrayType = 9;
pub const JSTypedArrayType_kJSTypedArrayTypeNone: JSTypedArrayType = 10;
pub const JSTypedArrayType_kJSTypedArrayTypeBigInt64Array: JSTypedArrayType = 11;
pub const JSTypedArrayType_kJSTypedArrayTypeBigUint64Array: JSTypedArrayType = 12;
#[doc = "@enum JSTypedArrayType\n@abstract     A constant identifying the Typed Array type of a JSObjectRef.\n@constant     kJSTypedArrayTypeInt8Array            Int8Array\n@constant     kJSTypedArrayTypeInt16Array           Int16Array\n@constant     kJSTypedArrayTypeInt32Array           Int32Array\n@constant     kJSTypedArrayTypeUint8Array           Uint8Array\n@constant     kJSTypedArrayTypeUint8ClampedArray    Uint8ClampedArray\n@constant     kJSTypedArrayTypeUint16Array          Uint16Array\n@constant     kJSTypedArrayTypeUint32Array          Uint32Array\n@constant     kJSTypedArrayTypeFloat32Array         Float32Array\n@constant     kJSTypedArrayTypeFloat64Array         Float64Array\n@constant     kJSTypedArrayTypeBigInt64Array        BigInt64Array\n@constant     kJSTypedArrayTypeBigUint64Array       BigUint64Array\n@constant     kJSTypedArrayTypeArrayBuffer          ArrayBuffer\n@constant     kJSTypedArrayTypeNone                 Not a Typed Array\n"]
pub type JSTypedArrayType = ::std::os::raw::c_uint;
pub const kJSPropertyAttributeNone: _bindgen_ty_1 = 0;
pub const kJSPropertyAttributeReadOnly: _bindgen_ty_1 = 2;
pub const kJSPropertyAttributeDontEnum: _bindgen_ty_1 = 4;
pub const kJSPropertyAttributeDontDelete: _bindgen_ty_1 = 8;
#[doc = "@enum JSPropertyAttribute\n@constant kJSPropertyAttributeNone         Specifies that a property has no special attributes.\n@constant kJSPropertyAttributeReadOnly     Specifies that a property is read-only.\n@constant kJSPropertyAttributeDontEnum     Specifies that a property should not be enumerated by JSPropertyEnumerators and JavaScript for...in loops.\n@constant kJSPropertyAttributeDontDelete   Specifies that the delete operation should fail on a property."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = "@typedef JSPropertyAttributes\n@abstract A set of JSPropertyAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSPropertyAttributes = ::std::os::raw::c_uint;
pub const kJSClassAttributeNone: _bindgen_ty_2 = 0;
pub const kJSClassAttributeNoAutomaticPrototype: _bindgen_ty_2 = 2;
#[doc = "@enum JSClassAttribute\n@constant kJSClassAttributeNone Specifies that a class has no special attributes.\n@constant kJSClassAttributeNoAutomaticPrototype Specifies that a class should not automatically generate a shared prototype for its instance objects. Use kJSClassAttributeNoAutomaticPrototype in combination with JSObjectSetPrototype to manage prototypes manually."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = "@typedef JSClassAttributes\n@abstract A set of JSClassAttributes. Combine multiple attributes by logically ORing them together."]
pub type JSClassAttributes = ::std::os::raw::c_uint;
#[doc = "@typedef JSObjectInitializeCallback\n@abstract The callback invoked when an object is first created.\n@param ctx The execution context to use.\n@param object The JSObject being created.\n@discussion If you named your function Initialize, you would declare it like this:\n\nvoid Initialize(JSContextRef ctx, JSObjectRef object);\n\nUnlike the other object callbacks, the initialize callback is called on the least\nderived class (the parent class) first, and the most derived class last."]
pub type JSObjectInitializeCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef)>;
#[doc = "@typedef JSObjectFinalizeCallback\n@abstract The callback invoked when an object is finalized (prepared for garbage collection). An object may be finalized on any thread.\n@param object The JSObject being finalized.\n@discussion If you named your function Finalize, you would declare it like this:\n\nvoid Finalize(JSObjectRef object);\n\nThe finalize callback is called on the most derived class first, and the least\nderived class (the parent class) last.\n\nYou must not call any function that may cause a garbage collection or an allocation\nof a garbage collected object from within a JSObjectFinalizeCallback. This includes\nall functions that have a JSContextRef parameter."]
pub type JSObjectFinalizeCallback =
    ::std::option::Option<unsafe extern "C" fn(object: JSObjectRef)>;
#[doc = "@typedef JSObjectHasPropertyCallback\n@abstract The callback invoked when determining whether an object has a property.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property look up.\n@result true if object has the property, otherwise false.\n@discussion If you named your function HasProperty, you would declare it like this:\n\nbool HasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName);\n\nIf this function returns false, the hasProperty request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain.\n\nThis callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value would be expensive.\n\nIf this callback is NULL, the getProperty callback will be used to service hasProperty requests."]
pub type JSObjectHasPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(ctx: JSContextRef, object: JSObjectRef, propertyName: JSStringRef) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyCallback\n@abstract The callback invoked when getting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject to search for the property.\n@param propertyName A JSString containing the name of the property to get.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The property's value if object has the property, otherwise NULL.\n@discussion If you named your function GetProperty, you would declare it like this:\n\nJSValueRef GetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns NULL, the get request forwards to object's statically declared properties, then its parent class chain (which includes the default object class), then its prototype chain."]
pub type JSObjectGetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectSetPropertyCallback\n@abstract The callback invoked when setting a property's value.\n@param ctx The execution context to use.\n@param object The JSObject on which to set the property's value.\n@param propertyName A JSString containing the name of the property to set.\n@param value A JSValue to use as the property's value.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if the property was set, otherwise false.\n@discussion If you named your function SetProperty, you would declare it like this:\n\nbool SetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception);\n\nIf this function returns false, the set request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectSetPropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectDeletePropertyCallback\n@abstract The callback invoked when deleting a property.\n@param ctx The execution context to use.\n@param object The JSObject in which to delete the property.\n@param propertyName A JSString containing the name of the property to delete.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if propertyName was successfully deleted, otherwise false.\n@discussion If you named your function DeleteProperty, you would declare it like this:\n\nbool DeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);\n\nIf this function returns false, the delete request forwards to object's statically declared properties, then its parent class chain (which includes the default object class)."]
pub type JSObjectDeletePropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyName: JSStringRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectGetPropertyNamesCallback\n@abstract The callback invoked when collecting the names of an object's properties.\n@param ctx The execution context to use.\n@param object The JSObject whose property names are being collected.\n@param propertyNames A JavaScript property name accumulator in which to accumulate the names of object's properties.\n@discussion If you named your function GetPropertyNames, you would declare it like this:\n\nvoid GetPropertyNames(JSContextRef ctx, JSObjectRef object, JSPropertyNameAccumulatorRef propertyNames);\n\nProperty name accumulators are used by JSObjectCopyPropertyNames and JavaScript for...in loops.\n\nUse JSPropertyNameAccumulatorAddName to add property names to accumulator. A class's getPropertyNames callback only needs to provide the names of properties that the class vends through a custom getProperty or setProperty callback. Other properties, including statically declared properties, properties vended by other classes, and properties belonging to object's prototype, are added independently."]
pub type JSObjectGetPropertyNamesCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        propertyNames: JSPropertyNameAccumulatorRef,
    ),
>;
#[doc = "@typedef JSObjectCallAsFunctionCallback\n@abstract The callback invoked when an object is called as a function.\n@param ctx The execution context to use.\n@param function A JSObject that is the function being called.\n@param thisObject A JSObject that is the 'this' variable in the function's scope.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSValue that is the function's return value.\n@discussion If you named your function CallAsFunction, you would declare it like this:\n\nJSValueRef CallAsFunction(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'myObject.myFunction()', function would be set to myFunction, and thisObject would be set to myObject.\n\nIf this callback is NULL, calling your object as a function will throw an exception."]
pub type JSObjectCallAsFunctionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        function: JSObjectRef,
        thisObject: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@typedef JSObjectCallAsConstructorCallback\n@abstract The callback invoked when an object is used as a constructor in a 'new' expression.\n@param ctx The execution context to use.\n@param constructor A JSObject that is the constructor being called.\n@param argumentCount An integer count of the number of arguments in arguments.\n@param arguments A JSValue array of the  arguments passed to the function.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result A JSObject that is the constructor's return value.\n@discussion If you named your function CallAsConstructor, you would declare it like this:\n\nJSObjectRef CallAsConstructor(JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'new myConstructor()', constructor would be set to myConstructor.\n\nIf this callback is NULL, using your object as a constructor in a 'new' expression will throw an exception."]
pub type JSObjectCallAsConstructorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        argumentCount: usize,
        arguments: *const JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef,
>;
#[doc = "@typedef JSObjectHasInstanceCallback\n@abstract hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@param ctx The execution context to use.\n@param constructor The JSObject that is the target of the 'instanceof' expression.\n@param possibleInstance The JSValue being tested to determine if it is an instance of constructor.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result true if possibleInstance is an instance of constructor, otherwise false.\n@discussion If you named your function HasInstance, you would declare it like this:\n\nbool HasInstance(JSContextRef ctx, JSObjectRef constructor, JSValueRef possibleInstance, JSValueRef* exception);\n\nIf your callback were invoked by the JavaScript expression 'someValue instanceof myObject', constructor would be set to myObject and possibleInstance would be set to someValue.\n\nIf this callback is NULL, 'instanceof' expressions that target your object will return false.\n\nStandard JavaScript practice calls for objects that implement the callAsConstructor callback to implement the hasInstance callback as well."]
pub type JSObjectHasInstanceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        constructor: JSObjectRef,
        possibleInstance: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool,
>;
#[doc = "@typedef JSObjectConvertToTypeCallback\n@abstract The callback invoked when converting an object to a particular JavaScript type.\n@param ctx The execution context to use.\n@param object The JSObject to convert.\n@param type A JSType specifying the JavaScript type to convert to.\n@param exception A pointer to a JSValueRef in which to return an exception, if any.\n@result The objects's converted value, or NULL if the object was not converted.\n@discussion If you named your function ConvertToType, you would declare it like this:\n\nJSValueRef ConvertToType(JSContextRef ctx, JSObjectRef object, JSType type, JSValueRef* exception);\n\nIf this function returns false, the conversion request forwards to object's parent class chain (which includes the default object class).\n\nThis function is only invoked when converting an object to number or string. An object converted to boolean is 'true.' An object converted to object is itself."]
pub type JSObjectConvertToTypeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: JSContextRef,
        object: JSObjectRef,
        type_: JSType,
        exception: *mut JSValueRef,
    ) -> JSValueRef,
>;
#[doc = "@struct JSStaticValue\n@abstract This structure describes a statically declared value property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field getProperty A JSObjectGetPropertyCallback to invoke when getting the property's value.\n@field setProperty A JSObjectSetPropertyCallback to invoke when setting the property's value. May be NULL if the ReadOnly attribute is set.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JSStaticValue {
    pub name: *const ::std::os::raw::c_char,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub attributes: JSPropertyAttributes,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSStaticValue"][::std::mem::size_of::<JSStaticValue>() - 32usize];
    ["Alignment of JSStaticValue"][::std::mem::align_of::<JSStaticValue>() - 8usize];
    ["Offset of field: JSStaticValue::name"][::std::mem::offset_of!(JSStaticValue, name) - 0usize];
    ["Offset of field: JSStaticValue::getProperty"]
        [::std::mem::offset_of!(JSStaticValue, getProperty) - 8usize];
    ["Offset of field: JSStaticValue::setProperty"]
        [::std::mem::offset_of!(JSStaticValue, setProperty) - 16usize];
    ["Offset of field: JSStaticValue::attributes"]
        [::std::mem::offset_of!(JSStaticValue, attributes) - 24usize];
};
impl Default for JSStaticValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "@struct JSStaticFunction\n@abstract This structure describes a statically declared function property.\n@field name A null-terminated UTF8 string containing the property's name.\n@field callAsFunction A JSObjectCallAsFunctionCallback to invoke when the property is called as a function.\n@field attributes A logically ORed set of JSPropertyAttributes to give to the property."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JSStaticFunction {
    pub name: *const ::std::os::raw::c_char,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub attributes: JSPropertyAttributes,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSStaticFunction"][::std::mem::size_of::<JSStaticFunction>() - 24usize];
    ["Alignment of JSStaticFunction"][::std::mem::align_of::<JSStaticFunction>() - 8usize];
    ["Offset of field: JSStaticFunction::name"]
        [::std::mem::offset_of!(JSStaticFunction, name) - 0usize];
    ["Offset of field: JSStaticFunction::callAsFunction"]
        [::std::mem::offset_of!(JSStaticFunction, callAsFunction) - 8usize];
    ["Offset of field: JSStaticFunction::attributes"]
        [::std::mem::offset_of!(JSStaticFunction, attributes) - 16usize];
};
impl Default for JSStaticFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "@struct JSClassDefinition\n@abstract This structure contains properties and callbacks that define a type of object. All fields other than the version field are optional. Any pointer may be NULL.\n@field version The version number of this structure. The current version is 0.\n@field attributes A logically ORed set of JSClassAttributes to give to the class.\n@field className A null-terminated UTF8 string containing the class's name.\n@field parentClass A JSClass to set as the class's parent class. Pass NULL use the default object class.\n@field staticValues A JSStaticValue array containing the class's statically declared value properties. Pass NULL to specify no statically declared value properties. The array must be terminated by a JSStaticValue whose name field is NULL.\n@field staticFunctions A JSStaticFunction array containing the class's statically declared function properties. Pass NULL to specify no statically declared function properties. The array must be terminated by a JSStaticFunction whose name field is NULL.\n@field initialize The callback invoked when an object is first created. Use this callback to initialize the object.\n@field finalize The callback invoked when an object is finalized (prepared for garbage collection). Use this callback to release resources allocated for the object, and perform other cleanup.\n@field hasProperty The callback invoked when determining whether an object has a property. If this field is NULL, getProperty is called instead. The hasProperty callback enables optimization in cases where only a property's existence needs to be known, not its value, and computing its value is expensive.\n@field getProperty The callback invoked when getting a property's value.\n@field setProperty The callback invoked when setting a property's value.\n@field deleteProperty The callback invoked when deleting a property.\n@field getPropertyNames The callback invoked when collecting the names of an object's properties.\n@field callAsFunction The callback invoked when an object is called as a function.\n@field hasInstance The callback invoked when an object is used as the target of an 'instanceof' expression.\n@field callAsConstructor The callback invoked when an object is used as a constructor in a 'new' expression.\n@field convertToType The callback invoked when converting an object to a particular JavaScript type.\n@discussion The staticValues and staticFunctions arrays are the simplest and most efficient means for vending custom properties. Statically declared properties autmatically service requests like getProperty, setProperty, and getPropertyNames. Property access callbacks are required only to implement unusual properties, like array indexes, whose names are not known at compile-time.\n\nIf you named your getter function \"GetX\" and your setter function \"SetX\", you would declare a JSStaticValue array containing \"X\" like this:\n\nJSStaticValue StaticValueArray[] = {\n{ \"X\", GetX, SetX, kJSPropertyAttributeNone },\n{ 0, 0, 0, 0 }\n};\n\nStandard JavaScript practice calls for storing function objects in prototypes, so they can be shared. The default JSClass created by JSClassCreate follows this idiom, instantiating objects with a shared, automatically generating prototype containing the class's function objects. The kJSClassAttributeNoAutomaticPrototype attribute specifies that a JSClass should not automatically generate such a prototype. The resulting JSClass instantiates objects with the default object prototype, and gives each instance object its own copy of the class's function objects.\n\nA NULL callback specifies that the default object callback should substitute, except in the case of hasProperty, where it specifies that getProperty should substitute.\n\nIt is not possible to use JS subclassing with objects created from a class definition that sets callAsConstructor by default. Subclassing is supported via the JSObjectMakeConstructor function, however."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct JSClassDefinition {
    pub version: ::std::os::raw::c_int,
    pub attributes: JSClassAttributes,
    pub className: *const ::std::os::raw::c_char,
    pub parentClass: JSClassRef,
    pub staticValues: *const JSStaticValue,
    pub staticFunctions: *const JSStaticFunction,
    pub initialize: JSObjectInitializeCallback,
    pub finalize: JSObjectFinalizeCallback,
    pub hasProperty: JSObjectHasPropertyCallback,
    pub getProperty: JSObjectGetPropertyCallback,
    pub setProperty: JSObjectSetPropertyCallback,
    pub deleteProperty: JSObjectDeletePropertyCallback,
    pub getPropertyNames: JSObjectGetPropertyNamesCallback,
    pub callAsFunction: JSObjectCallAsFunctionCallback,
    pub callAsConstructor: JSObjectCallAsConstructorCallback,
    pub hasInstance: JSObjectHasInstanceCallback,
    pub convertToType: JSObjectConvertToTypeCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSClassDefinition"][::std::mem::size_of::<JSClassDefinition>() - 128usize];
    ["Alignment of JSClassDefinition"][::std::mem::align_of::<JSClassDefinition>() - 8usize];
    ["Offset of field: JSClassDefinition::version"]
        [::std::mem::offset_of!(JSClassDefinition, version) - 0usize];
    ["Offset of field: JSClassDefinition::attributes"]
        [::std::mem::offset_of!(JSClassDefinition, attributes) - 4usize];
    ["Offset of field: JSClassDefinition::className"]
        [::std::mem::offset_of!(JSClassDefinition, className) - 8usize];
    ["Offset of field: JSClassDefinition::parentClass"]
        [::std::mem::offset_of!(JSClassDefinition, parentClass) - 16usize];
    ["Offset of field: JSClassDefinition::staticValues"]
        [::std::mem::offset_of!(JSClassDefinition, staticValues) - 24usize];
    ["Offset of field: JSClassDefinition::staticFunctions"]
        [::std::mem::offset_of!(JSClassDefinition, staticFunctions) - 32usize];
    ["Offset of field: JSClassDefinition::initialize"]
        [::std::mem::offset_of!(JSClassDefinition, initialize) - 40usize];
    ["Offset of field: JSClassDefinition::finalize"]
        [::std::mem::offset_of!(JSClassDefinition, finalize) - 48usize];
    ["Offset of field: JSClassDefinition::hasProperty"]
        [::std::mem::offset_of!(JSClassDefinition, hasProperty) - 56usize];
    ["Offset of field: JSClassDefinition::getProperty"]
        [::std::mem::offset_of!(JSClassDefinition, getProperty) - 64usize];
    ["Offset of field: JSClassDefinition::setProperty"]
        [::std::mem::offset_of!(JSClassDefinition, setProperty) - 72usize];
    ["Offset of field: JSClassDefinition::deleteProperty"]
        [::std::mem::offset_of!(JSClassDefinition, deleteProperty) - 80usize];
    ["Offset of field: JSClassDefinition::getPropertyNames"]
        [::std::mem::offset_of!(JSClassDefinition, getPropertyNames) - 88usize];
    ["Offset of field: JSClassDefinition::callAsFunction"]
        [::std::mem::offset_of!(JSClassDefinition, callAsFunction) - 96usize];
    ["Offset of field: JSClassDefinition::callAsConstructor"]
        [::std::mem::offset_of!(JSClassDefinition, callAsConstructor) - 104usize];
    ["Offset of field: JSClassDefinition::hasInstance"]
        [::std::mem::offset_of!(JSClassDefinition, hasInstance) - 112usize];
    ["Offset of field: JSClassDefinition::convertToType"]
        [::std::mem::offset_of!(JSClassDefinition, convertToType) - 120usize];
};
impl Default for JSClassDefinition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "@typedef JSChar\n@abstract A UTF-16 code unit. One, or a sequence of two, can encode any Unicode\ncharacter. As with all scalar types, endianness depends on the underlying\narchitecture."]
pub type JSChar = ::std::os::raw::c_ushort;
pub type ULChar16 = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Config {
    _unused: [u8; 0],
}
pub type ULConfig = *mut C_Config;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Renderer {
    _unused: [u8; 0],
}
pub type ULRenderer = *mut C_Renderer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Session {
    _unused: [u8; 0],
}
pub type ULSession = *mut C_Session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ViewConfig {
    _unused: [u8; 0],
}
pub type ULViewConfig = *mut C_ViewConfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_View {
    _unused: [u8; 0],
}
pub type ULView = *mut C_View;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Bitmap {
    _unused: [u8; 0],
}
pub type ULBitmap = *mut C_Bitmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_String {
    _unused: [u8; 0],
}
pub type ULString = *mut C_String;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Buffer {
    _unused: [u8; 0],
}
pub type ULBuffer = *mut C_Buffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_KeyEvent {
    _unused: [u8; 0],
}
pub type ULKeyEvent = *mut C_KeyEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_MouseEvent {
    _unused: [u8; 0],
}
pub type ULMouseEvent = *mut C_MouseEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ScrollEvent {
    _unused: [u8; 0],
}
pub type ULScrollEvent = *mut C_ScrollEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadEvent {
    _unused: [u8; 0],
}
pub type ULGamepadEvent = *mut C_GamepadEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadAxisEvent {
    _unused: [u8; 0],
}
pub type ULGamepadAxisEvent = *mut C_GamepadAxisEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_GamepadButtonEvent {
    _unused: [u8; 0],
}
pub type ULGamepadButtonEvent = *mut C_GamepadButtonEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Surface {
    _unused: [u8; 0],
}
pub type ULSurface = *mut C_Surface;
pub type ULBitmapSurface = *mut C_Surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_FontFile {
    _unused: [u8; 0],
}
pub type ULFontFile = *mut C_FontFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_ImageSource {
    _unused: [u8; 0],
}
pub type ULImageSource = *mut C_ImageSource;
pub const ULMessageSource_kMessageSource_XML: ULMessageSource = 0;
pub const ULMessageSource_kMessageSource_JS: ULMessageSource = 1;
pub const ULMessageSource_kMessageSource_Network: ULMessageSource = 2;
pub const ULMessageSource_kMessageSource_ConsoleAPI: ULMessageSource = 3;
pub const ULMessageSource_kMessageSource_Storage: ULMessageSource = 4;
pub const ULMessageSource_kMessageSource_AppCache: ULMessageSource = 5;
pub const ULMessageSource_kMessageSource_Rendering: ULMessageSource = 6;
pub const ULMessageSource_kMessageSource_CSS: ULMessageSource = 7;
pub const ULMessageSource_kMessageSource_Security: ULMessageSource = 8;
pub const ULMessageSource_kMessageSource_ContentBlocker: ULMessageSource = 9;
pub const ULMessageSource_kMessageSource_Media: ULMessageSource = 10;
pub const ULMessageSource_kMessageSource_MediaSource: ULMessageSource = 11;
pub const ULMessageSource_kMessageSource_WebRTC: ULMessageSource = 12;
pub const ULMessageSource_kMessageSource_ITPDebug: ULMessageSource = 13;
pub const ULMessageSource_kMessageSource_PrivateClickMeasurement: ULMessageSource = 14;
pub const ULMessageSource_kMessageSource_PaymentRequest: ULMessageSource = 15;
pub const ULMessageSource_kMessageSource_Other: ULMessageSource = 16;
pub type ULMessageSource = ::std::os::raw::c_uint;
pub const ULMessageLevel_kMessageLevel_Log: ULMessageLevel = 0;
pub const ULMessageLevel_kMessageLevel_Warning: ULMessageLevel = 1;
pub const ULMessageLevel_kMessageLevel_Error: ULMessageLevel = 2;
pub const ULMessageLevel_kMessageLevel_Debug: ULMessageLevel = 3;
pub const ULMessageLevel_kMessageLevel_Info: ULMessageLevel = 4;
pub type ULMessageLevel = ::std::os::raw::c_uint;
pub const ULCursor_kCursor_Pointer: ULCursor = 0;
pub const ULCursor_kCursor_Cross: ULCursor = 1;
pub const ULCursor_kCursor_Hand: ULCursor = 2;
pub const ULCursor_kCursor_IBeam: ULCursor = 3;
pub const ULCursor_kCursor_Wait: ULCursor = 4;
pub const ULCursor_kCursor_Help: ULCursor = 5;
pub const ULCursor_kCursor_EastResize: ULCursor = 6;
pub const ULCursor_kCursor_NorthResize: ULCursor = 7;
pub const ULCursor_kCursor_NorthEastResize: ULCursor = 8;
pub const ULCursor_kCursor_NorthWestResize: ULCursor = 9;
pub const ULCursor_kCursor_SouthResize: ULCursor = 10;
pub const ULCursor_kCursor_SouthEastResize: ULCursor = 11;
pub const ULCursor_kCursor_SouthWestResize: ULCursor = 12;
pub const ULCursor_kCursor_WestResize: ULCursor = 13;
pub const ULCursor_kCursor_NorthSouthResize: ULCursor = 14;
pub const ULCursor_kCursor_EastWestResize: ULCursor = 15;
pub const ULCursor_kCursor_NorthEastSouthWestResize: ULCursor = 16;
pub const ULCursor_kCursor_NorthWestSouthEastResize: ULCursor = 17;
pub const ULCursor_kCursor_ColumnResize: ULCursor = 18;
pub const ULCursor_kCursor_RowResize: ULCursor = 19;
pub const ULCursor_kCursor_MiddlePanning: ULCursor = 20;
pub const ULCursor_kCursor_EastPanning: ULCursor = 21;
pub const ULCursor_kCursor_NorthPanning: ULCursor = 22;
pub const ULCursor_kCursor_NorthEastPanning: ULCursor = 23;
pub const ULCursor_kCursor_NorthWestPanning: ULCursor = 24;
pub const ULCursor_kCursor_SouthPanning: ULCursor = 25;
pub const ULCursor_kCursor_SouthEastPanning: ULCursor = 26;
pub const ULCursor_kCursor_SouthWestPanning: ULCursor = 27;
pub const ULCursor_kCursor_WestPanning: ULCursor = 28;
pub const ULCursor_kCursor_Move: ULCursor = 29;
pub const ULCursor_kCursor_VerticalText: ULCursor = 30;
pub const ULCursor_kCursor_Cell: ULCursor = 31;
pub const ULCursor_kCursor_ContextMenu: ULCursor = 32;
pub const ULCursor_kCursor_Alias: ULCursor = 33;
pub const ULCursor_kCursor_Progress: ULCursor = 34;
pub const ULCursor_kCursor_NoDrop: ULCursor = 35;
pub const ULCursor_kCursor_Copy: ULCursor = 36;
pub const ULCursor_kCursor_None: ULCursor = 37;
pub const ULCursor_kCursor_NotAllowed: ULCursor = 38;
pub const ULCursor_kCursor_ZoomIn: ULCursor = 39;
pub const ULCursor_kCursor_ZoomOut: ULCursor = 40;
pub const ULCursor_kCursor_Grab: ULCursor = 41;
pub const ULCursor_kCursor_Grabbing: ULCursor = 42;
pub const ULCursor_kCursor_Custom: ULCursor = 43;
pub type ULCursor = ::std::os::raw::c_uint;
#[doc = "\n Alpha channel only, 8-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: Linear (no gamma), alpha-coverage only.\n"]
pub const ULBitmapFormat_kBitmapFormat_A8_UNORM: ULBitmapFormat = 0;
#[doc = "\n Blue Green Red Alpha channels, 32-bits per pixel.\n\n Encoding: 8-bits per channel, unsigned normalized.\n\n Color-space: sRGB gamma with premultiplied linear alpha channel.\n"]
pub const ULBitmapFormat_kBitmapFormat_BGRA8_UNORM_SRGB: ULBitmapFormat = 1;
pub type ULBitmapFormat = ::std::os::raw::c_uint;
#[doc = "\n Key-Down event type. This type does **not** trigger accelerator commands in WebCore (eg,\n Ctrl+C for copy is an accelerator command).\n\n @warning  You should probably use kKeyEventType_RawKeyDown instead. This type is only here for\n           historic compatibility with WebCore's key event types.\n"]
pub const ULKeyEventType_kKeyEventType_KeyDown: ULKeyEventType = 0;
#[doc = "\n Key-Up event type. Use this when a physical key is released.\n"]
pub const ULKeyEventType_kKeyEventType_KeyUp: ULKeyEventType = 1;
#[doc = "\n Raw Key-Down type. Use this when a physical key is pressed.\n"]
pub const ULKeyEventType_kKeyEventType_RawKeyDown: ULKeyEventType = 2;
#[doc = "\n Character input event type. Use this when the OS generates text from\n a physical key being pressed (eg, WM_CHAR on Windows).\n"]
pub const ULKeyEventType_kKeyEventType_Char: ULKeyEventType = 3;
pub type ULKeyEventType = ::std::os::raw::c_uint;
pub const ULMouseEventType_kMouseEventType_MouseMoved: ULMouseEventType = 0;
pub const ULMouseEventType_kMouseEventType_MouseDown: ULMouseEventType = 1;
pub const ULMouseEventType_kMouseEventType_MouseUp: ULMouseEventType = 2;
pub type ULMouseEventType = ::std::os::raw::c_uint;
pub const ULMouseButton_kMouseButton_None: ULMouseButton = 0;
pub const ULMouseButton_kMouseButton_Left: ULMouseButton = 1;
pub const ULMouseButton_kMouseButton_Middle: ULMouseButton = 2;
pub const ULMouseButton_kMouseButton_Right: ULMouseButton = 3;
pub type ULMouseButton = ::std::os::raw::c_uint;
pub const ULScrollEventType_kScrollEventType_ScrollByPixel: ULScrollEventType = 0;
pub const ULScrollEventType_kScrollEventType_ScrollByPage: ULScrollEventType = 1;
pub type ULScrollEventType = ::std::os::raw::c_uint;
pub const ULGamepadEventType_kGamepadEventType_Connected: ULGamepadEventType = 0;
pub const ULGamepadEventType_kGamepadEventType_Disconnected: ULGamepadEventType = 1;
pub type ULGamepadEventType = ::std::os::raw::c_uint;
pub const ULFaceWinding_kFaceWinding_Clockwise: ULFaceWinding = 0;
pub const ULFaceWinding_kFaceWinding_CounterClockwise: ULFaceWinding = 1;
pub type ULFaceWinding = ::std::os::raw::c_uint;
#[doc = "\n Lighter hinting algorithm-- glyphs are slightly fuzzier but better\n resemble their original shape. This is achieved by snapping glyphs to the\n pixel grid only vertically which better preserves inter-glyph spacing.\n"]
pub const ULFontHinting_kFontHinting_Smooth: ULFontHinting = 0;
#[doc = "\n Default hinting algorithm-- offers a good balance between sharpness and\n shape at smaller font sizes.\n"]
pub const ULFontHinting_kFontHinting_Normal: ULFontHinting = 1;
#[doc = "\n Strongest hinting algorithm-- outputs only black/white glyphs. The result\n is usually unpleasant if the underlying TTF does not contain hints for\n this type of rendering.\n"]
pub const ULFontHinting_kFontHinting_Monochrome: ULFontHinting = 2;
pub type ULFontHinting = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULRect {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULRect"][::std::mem::size_of::<ULRect>() - 16usize];
    ["Alignment of ULRect"][::std::mem::align_of::<ULRect>() - 4usize];
    ["Offset of field: ULRect::left"][::std::mem::offset_of!(ULRect, left) - 0usize];
    ["Offset of field: ULRect::top"][::std::mem::offset_of!(ULRect, top) - 4usize];
    ["Offset of field: ULRect::right"][::std::mem::offset_of!(ULRect, right) - 8usize];
    ["Offset of field: ULRect::bottom"][::std::mem::offset_of!(ULRect, bottom) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULIntRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULIntRect"][::std::mem::size_of::<ULIntRect>() - 16usize];
    ["Alignment of ULIntRect"][::std::mem::align_of::<ULIntRect>() - 4usize];
    ["Offset of field: ULIntRect::left"][::std::mem::offset_of!(ULIntRect, left) - 0usize];
    ["Offset of field: ULIntRect::top"][::std::mem::offset_of!(ULIntRect, top) - 4usize];
    ["Offset of field: ULIntRect::right"][::std::mem::offset_of!(ULIntRect, right) - 8usize];
    ["Offset of field: ULIntRect::bottom"][::std::mem::offset_of!(ULIntRect, bottom) - 12usize];
};
#[doc = "\n Offscreen render target, used when rendering Views via the GPU renderer.\n\n When a View is rendered via the GPU renderer (see ulViewIsAccelerated()), it will be rendered to\n an offscreen render target (ulViewGetRenderTarget()) that you can display in your application.\n\n This is intended to be used with a custom ULGPUDriver implementation in a game or similar\n application (ulPlatformSetGPUDriver()).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ULRenderTarget {
    pub is_empty: bool,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub texture_id: ::std::os::raw::c_uint,
    pub texture_width: ::std::os::raw::c_uint,
    pub texture_height: ::std::os::raw::c_uint,
    pub texture_format: ULBitmapFormat,
    pub uv_coords: ULRect,
    pub render_buffer_id: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULRenderTarget"][::std::mem::size_of::<ULRenderTarget>() - 48usize];
    ["Alignment of ULRenderTarget"][::std::mem::align_of::<ULRenderTarget>() - 4usize];
    ["Offset of field: ULRenderTarget::is_empty"]
        [::std::mem::offset_of!(ULRenderTarget, is_empty) - 0usize];
    ["Offset of field: ULRenderTarget::width"]
        [::std::mem::offset_of!(ULRenderTarget, width) - 4usize];
    ["Offset of field: ULRenderTarget::height"]
        [::std::mem::offset_of!(ULRenderTarget, height) - 8usize];
    ["Offset of field: ULRenderTarget::texture_id"]
        [::std::mem::offset_of!(ULRenderTarget, texture_id) - 12usize];
    ["Offset of field: ULRenderTarget::texture_width"]
        [::std::mem::offset_of!(ULRenderTarget, texture_width) - 16usize];
    ["Offset of field: ULRenderTarget::texture_height"]
        [::std::mem::offset_of!(ULRenderTarget, texture_height) - 20usize];
    ["Offset of field: ULRenderTarget::texture_format"]
        [::std::mem::offset_of!(ULRenderTarget, texture_format) - 24usize];
    ["Offset of field: ULRenderTarget::uv_coords"]
        [::std::mem::offset_of!(ULRenderTarget, uv_coords) - 28usize];
    ["Offset of field: ULRenderTarget::render_buffer_id"]
        [::std::mem::offset_of!(ULRenderTarget, render_buffer_id) - 44usize];
};
impl Default for ULRenderTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ulDestroyBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, data: *mut ::std::os::raw::c_void),
>;
#[doc = "\n The callback invoked when the library wants to clear the system's clipboard.\n"]
pub type ULClipboardClearCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n The callback invoked when the library wants to read from the system's clipboard.\n\n You should store the result (if any) in 'result'.\n"]
pub type ULClipboardReadPlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(result: ULString)>;
#[doc = "\n The callback invoked when the library wants to write to the system's clipboard.\n"]
pub type ULClipboardWritePlainTextCallback =
    ::std::option::Option<unsafe extern "C" fn(text: ULString)>;
#[doc = "\n User-defined clipboard interface.\n\n You should implement each of these callbacks, then pass an instance of this struct containing\n your callbacks to ulPlatformSetClipboard().\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULClipboard {
    pub clear: ULClipboardClearCallback,
    pub read_plain_text: ULClipboardReadPlainTextCallback,
    pub write_plain_text: ULClipboardWritePlainTextCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULClipboard"][::std::mem::size_of::<ULClipboard>() - 24usize];
    ["Alignment of ULClipboard"][::std::mem::align_of::<ULClipboard>() - 8usize];
    ["Offset of field: ULClipboard::clear"][::std::mem::offset_of!(ULClipboard, clear) - 0usize];
    ["Offset of field: ULClipboard::read_plain_text"]
        [::std::mem::offset_of!(ULClipboard, read_plain_text) - 8usize];
    ["Offset of field: ULClipboard::write_plain_text"]
        [::std::mem::offset_of!(ULClipboard, write_plain_text) - 16usize];
};
#[doc = "\n The callback invoked when the FileSystem wants to check if a file path exists, return true if it\n exists.\n"]
pub type ULFileSystemFileExistsCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> bool>;
#[doc = "\n Get the mime-type of the file (eg \"text/html\").\n\n This is usually determined by analyzing the file extension.\n\n If a mime-type cannot be determined, you should return \"application/unknown\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileMimeTypeCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Get the charset / encoding of the file (eg \"utf-8\").\n\n This is only important for text-based files and is usually determined by analyzing the\n contents of the file.\n\n If a charset cannot be determined, it's usually safe to return \"utf-8\" for this value.\n\n The library will consume the result and call ulDestroyString() after this call returns.\n"]
pub type ULFileSystemGetFileCharsetCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULString>;
#[doc = "\n Open file for reading and map it to a Buffer.\n\n To minimize copies, you should map the requested file into memory and use ulCreateBuffer()\n to wrap the data pointer (unmapping should be performed in the destruction callback).\n\n If the file was unable to be opened, you should return NULL for this value.\n"]
pub type ULFileSystemOpenFileCallback =
    ::std::option::Option<unsafe extern "C" fn(path: ULString) -> ULBuffer>;
#[doc = "\n User-defined file system interface.\n\n You should implement each of these callbacks, then pass an instance of this struct containing\n your callbacks to ulPlatformSetFileSystem().\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULFileSystem {
    pub file_exists: ULFileSystemFileExistsCallback,
    pub get_file_mime_type: ULFileSystemGetFileMimeTypeCallback,
    pub get_file_charset: ULFileSystemGetFileCharsetCallback,
    pub open_file: ULFileSystemOpenFileCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULFileSystem"][::std::mem::size_of::<ULFileSystem>() - 32usize];
    ["Alignment of ULFileSystem"][::std::mem::align_of::<ULFileSystem>() - 8usize];
    ["Offset of field: ULFileSystem::file_exists"]
        [::std::mem::offset_of!(ULFileSystem, file_exists) - 0usize];
    ["Offset of field: ULFileSystem::get_file_mime_type"]
        [::std::mem::offset_of!(ULFileSystem, get_file_mime_type) - 8usize];
    ["Offset of field: ULFileSystem::get_file_charset"]
        [::std::mem::offset_of!(ULFileSystem, get_file_charset) - 16usize];
    ["Offset of field: ULFileSystem::open_file"]
        [::std::mem::offset_of!(ULFileSystem, open_file) - 24usize];
};
#[doc = "\n Fallback font family name. Will be used if all other fonts fail to load.\n\n @note  This font should be guaranteed to exist (eg, ULFontLoader::load should not fail when\n        when passed this font family name).\n\n @note  The returned ULString instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFont = ::std::option::Option<unsafe extern "C" fn() -> ULString>;
#[doc = "\n Fallback font family name that can render the specified characters. This is mainly used to\n support CJK (Chinese, Japanese, Korean) text display.\n\n @param  characters  One or more UTF-16 characters. This is almost always a single character.\n\n @param  weight      Font weight.\n\n @param  italic      Whether or not italic is requested.\n\n @return  Should return a font family name that can render the text. The returned ULString\n          instance will be consumed (ulDestroyString will be called on it).\n"]
pub type ULFontLoaderGetFallbackFontForCharacters = ::std::option::Option<
    unsafe extern "C" fn(
        characters: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULString,
>;
#[doc = "\n Get the actual font file data (TTF/OTF) for a given font description.\n\n @param  family  Font family name.\n\n @param  weight  Font weight.\n\n @param  italic  Whether or not italic is requested.\n\n @return  A font file matching the given description (either an on-disk font filepath or an\n          in-memory file buffer). You can return NULL here and the loader will fallback to\n          another font.\n"]
pub type ULFontLoaderLoad = ::std::option::Option<
    unsafe extern "C" fn(
        family: ULString,
        weight: ::std::os::raw::c_int,
        italic: bool,
    ) -> ULFontFile,
>;
#[doc = "\n User-defined font loader interface.\n\n You should implement each of these callbacks, then pass an instance of this struct containing\n your callbacks to ulPlatformSetFontLoader().\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULFontLoader {
    pub get_fallback_font: ULFontLoaderGetFallbackFont,
    pub get_fallback_font_for_characters: ULFontLoaderGetFallbackFontForCharacters,
    pub load: ULFontLoaderLoad,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULFontLoader"][::std::mem::size_of::<ULFontLoader>() - 24usize];
    ["Alignment of ULFontLoader"][::std::mem::align_of::<ULFontLoader>() - 8usize];
    ["Offset of field: ULFontLoader::get_fallback_font"]
        [::std::mem::offset_of!(ULFontLoader, get_fallback_font) - 0usize];
    ["Offset of field: ULFontLoader::get_fallback_font_for_characters"]
        [::std::mem::offset_of!(ULFontLoader, get_fallback_font_for_characters) - 8usize];
    ["Offset of field: ULFontLoader::load"][::std::mem::offset_of!(ULFontLoader, load) - 16usize];
};
#[doc = "\n Render buffer description.\n\n This structure describes a render buffer that can be used as a target for drawing commands.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULRenderBuffer {
    #[doc = "< The backing texture for this RenderBuffer"]
    pub texture_id: ::std::os::raw::c_uint,
    #[doc = "< The width of the RenderBuffer texture"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< The height of the RenderBuffer texture"]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< Currently unused, always false."]
    pub has_stencil_buffer: bool,
    #[doc = "< Currently unsued, always false."]
    pub has_depth_buffer: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULRenderBuffer"][::std::mem::size_of::<ULRenderBuffer>() - 16usize];
    ["Alignment of ULRenderBuffer"][::std::mem::align_of::<ULRenderBuffer>() - 4usize];
    ["Offset of field: ULRenderBuffer::texture_id"]
        [::std::mem::offset_of!(ULRenderBuffer, texture_id) - 0usize];
    ["Offset of field: ULRenderBuffer::width"]
        [::std::mem::offset_of!(ULRenderBuffer, width) - 4usize];
    ["Offset of field: ULRenderBuffer::height"]
        [::std::mem::offset_of!(ULRenderBuffer, height) - 8usize];
    ["Offset of field: ULRenderBuffer::has_stencil_buffer"]
        [::std::mem::offset_of!(ULRenderBuffer, has_stencil_buffer) - 12usize];
    ["Offset of field: ULRenderBuffer::has_depth_buffer"]
        [::std::mem::offset_of!(ULRenderBuffer, has_depth_buffer) - 13usize];
};
#[doc = "\n Vertex layout for path vertices.\n\n This struct is the in-memory layout for each path vertex (useful for synthesizing or modifying\n your own vertex data).\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULVertex_2f_4ub_2f {
    pub pos: [f32; 2usize],
    pub color: [::std::os::raw::c_uchar; 4usize],
    pub obj: [f32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULVertex_2f_4ub_2f"][::std::mem::size_of::<ULVertex_2f_4ub_2f>() - 20usize];
    ["Alignment of ULVertex_2f_4ub_2f"][::std::mem::align_of::<ULVertex_2f_4ub_2f>() - 1usize];
    ["Offset of field: ULVertex_2f_4ub_2f::pos"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f, pos) - 0usize];
    ["Offset of field: ULVertex_2f_4ub_2f::color"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f, color) - 8usize];
    ["Offset of field: ULVertex_2f_4ub_2f::obj"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f, obj) - 12usize];
};
#[doc = "\n Vertex layout for quad vertices.\n\n This struct is the in-memory layout for each quad vertex (useful for synthesizing or modifying\n your own vertex data).\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULVertex_2f_4ub_2f_2f_28f {
    pub pos: [f32; 2usize],
    pub color: [::std::os::raw::c_uchar; 4usize],
    pub tex: [f32; 2usize],
    pub obj: [f32; 2usize],
    pub data0: [f32; 4usize],
    pub data1: [f32; 4usize],
    pub data2: [f32; 4usize],
    pub data3: [f32; 4usize],
    pub data4: [f32; 4usize],
    pub data5: [f32; 4usize],
    pub data6: [f32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULVertex_2f_4ub_2f_2f_28f"]
        [::std::mem::size_of::<ULVertex_2f_4ub_2f_2f_28f>() - 140usize];
    ["Alignment of ULVertex_2f_4ub_2f_2f_28f"]
        [::std::mem::align_of::<ULVertex_2f_4ub_2f_2f_28f>() - 1usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::pos"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, pos) - 0usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::color"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, color) - 8usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::tex"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, tex) - 12usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::obj"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, obj) - 20usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data0"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data0) - 28usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data1"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data1) - 44usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data2"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data2) - 60usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data3"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data3) - 76usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data4"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data4) - 92usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data5"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data5) - 108usize];
    ["Offset of field: ULVertex_2f_4ub_2f_2f_28f::data6"]
        [::std::mem::offset_of!(ULVertex_2f_4ub_2f_2f_28f, data6) - 124usize];
};
#[doc = "< Vertex_2f_4ub_2f (used for path rendering)"]
pub const ULVertexBufferFormat_kVertexBufferFormat_2f_4ub_2f: ULVertexBufferFormat = 0;
#[doc = "< Vertex_2f_4ub_2f_2f_28f (used for quad rendering)"]
pub const ULVertexBufferFormat_kVertexBufferFormat_2f_4ub_2f_2f_28f: ULVertexBufferFormat = 1;
#[doc = "\n Vertex buffer formats.\n\n This enumeration describes the format of a vertex buffer.\n"]
pub type ULVertexBufferFormat = ::std::os::raw::c_uint;
#[doc = "\n Vertex buffer description.\n\n @see ULGPUDriver::create_geometry\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ULVertexBuffer {
    #[doc = "< The format of the vertex buffer."]
    pub format: ULVertexBufferFormat,
    #[doc = "< The size of the vertex buffer in bytes."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< The raw vertex buffer data."]
    pub data: *mut ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULVertexBuffer"][::std::mem::size_of::<ULVertexBuffer>() - 16usize];
    ["Alignment of ULVertexBuffer"][::std::mem::align_of::<ULVertexBuffer>() - 8usize];
    ["Offset of field: ULVertexBuffer::format"]
        [::std::mem::offset_of!(ULVertexBuffer, format) - 0usize];
    ["Offset of field: ULVertexBuffer::size"]
        [::std::mem::offset_of!(ULVertexBuffer, size) - 4usize];
    ["Offset of field: ULVertexBuffer::data"]
        [::std::mem::offset_of!(ULVertexBuffer, data) - 8usize];
};
impl Default for ULVertexBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n Vertex index type.\n"]
pub type ULIndexType = ::std::os::raw::c_uint;
#[doc = "\n Index buffer description.\n\n This structure describes an index buffer that can be used to index into a vertex buffer.\n\n @note The index buffer is a simple array of IndexType values.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ULIndexBuffer {
    #[doc = "< The size of the index buffer in bytes."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< The raw index buffer data."]
    pub data: *mut ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULIndexBuffer"][::std::mem::size_of::<ULIndexBuffer>() - 16usize];
    ["Alignment of ULIndexBuffer"][::std::mem::align_of::<ULIndexBuffer>() - 8usize];
    ["Offset of field: ULIndexBuffer::size"][::std::mem::offset_of!(ULIndexBuffer, size) - 0usize];
    ["Offset of field: ULIndexBuffer::data"][::std::mem::offset_of!(ULIndexBuffer, data) - 8usize];
};
impl Default for ULIndexBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Shader program for filling quad geometry."]
pub const ULShaderType_kShaderType_Fill: ULShaderType = 0;
#[doc = "< Shader program for filling tesselated path geometry."]
pub const ULShaderType_kShaderType_FillPath: ULShaderType = 1;
#[doc = "\n Shader program types, used with ULGPUState::shader_type\n\n Each of these correspond to a vertex/pixel shader pair. You can find stock shader code for these\n in the `shaders` folder of the AppCore repo.\n"]
pub type ULShaderType = ::std::os::raw::c_uint;
#[doc = "\n Raw 4x4 matrix as an array of floats\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULMatrix4x4 {
    pub data: [f32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULMatrix4x4"][::std::mem::size_of::<ULMatrix4x4>() - 64usize];
    ["Alignment of ULMatrix4x4"][::std::mem::align_of::<ULMatrix4x4>() - 4usize];
    ["Offset of field: ULMatrix4x4::data"][::std::mem::offset_of!(ULMatrix4x4, data) - 0usize];
};
#[doc = "\n 4-component float vector\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULvec4 {
    pub value: [f32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULvec4"][::std::mem::size_of::<ULvec4>() - 16usize];
    ["Alignment of ULvec4"][::std::mem::align_of::<ULvec4>() - 4usize];
    ["Offset of field: ULvec4::value"][::std::mem::offset_of!(ULvec4, value) - 0usize];
};
#[doc = "\n The state of the GPU for a given draw command.\n\n This structure describes the current state of the GPU for a given draw command.\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULGPUState {
    #[doc = " Viewport width in pixels"]
    pub viewport_width: ::std::os::raw::c_uint,
    #[doc = " Viewport height in pixels"]
    pub viewport_height: ::std::os::raw::c_uint,
    #[doc = " Transform matrix-- you should multiply this with the screen-space orthographic projection\n matrix then pass to the vertex shader."]
    pub transform: ULMatrix4x4,
    #[doc = " Whether or not we should enable texturing for the current draw command."]
    pub enable_texturing: bool,
    #[doc = " Whether or not we should enable blending for the current draw command. If blending is\n disabled, any drawn pixels should overwrite existing. Mainly used so we can modify alpha\n values of the RenderBuffer during scissored clears."]
    pub enable_blend: bool,
    #[doc = " The vertex/pixel shader program pair to use for the current draw command. You should cast this\n to ShaderType to get the corresponding enum."]
    pub shader_type: ::std::os::raw::c_uchar,
    #[doc = " The render buffer to use for the current draw command."]
    pub render_buffer_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #1. (Will be 0 if none)"]
    pub texture_1_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #2. (Will be 0 if none)"]
    pub texture_2_id: ::std::os::raw::c_uint,
    #[doc = " The texture id to bind to slot #3. (Will be 0 if none)"]
    pub texture_3_id: ::std::os::raw::c_uint,
    #[doc = " The uniform scalars (passed to the pixel shader via uniforms)."]
    pub uniform_scalar: [f32; 8usize],
    #[doc = " The uniform vectors (passed to the pixel shader via uniforms)."]
    pub uniform_vector: [ULvec4; 8usize],
    #[doc = " The clip size (passed to the pixel shader via uniforms)."]
    pub clip_size: ::std::os::raw::c_uchar,
    #[doc = " The clip stack (passed to the pixel shader via uniforms)."]
    pub clip: [ULMatrix4x4; 8usize],
    #[doc = " Whether or not scissor testing should be used for the current draw command."]
    pub enable_scissor: bool,
    #[doc = " The scissor rect to use for scissor testing (units in pixels)"]
    pub scissor_rect: ULIntRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULGPUState"][::std::mem::size_of::<ULGPUState>() - 788usize];
    ["Alignment of ULGPUState"][::std::mem::align_of::<ULGPUState>() - 4usize];
    ["Offset of field: ULGPUState::viewport_width"]
        [::std::mem::offset_of!(ULGPUState, viewport_width) - 0usize];
    ["Offset of field: ULGPUState::viewport_height"]
        [::std::mem::offset_of!(ULGPUState, viewport_height) - 4usize];
    ["Offset of field: ULGPUState::transform"]
        [::std::mem::offset_of!(ULGPUState, transform) - 8usize];
    ["Offset of field: ULGPUState::enable_texturing"]
        [::std::mem::offset_of!(ULGPUState, enable_texturing) - 72usize];
    ["Offset of field: ULGPUState::enable_blend"]
        [::std::mem::offset_of!(ULGPUState, enable_blend) - 73usize];
    ["Offset of field: ULGPUState::shader_type"]
        [::std::mem::offset_of!(ULGPUState, shader_type) - 74usize];
    ["Offset of field: ULGPUState::render_buffer_id"]
        [::std::mem::offset_of!(ULGPUState, render_buffer_id) - 76usize];
    ["Offset of field: ULGPUState::texture_1_id"]
        [::std::mem::offset_of!(ULGPUState, texture_1_id) - 80usize];
    ["Offset of field: ULGPUState::texture_2_id"]
        [::std::mem::offset_of!(ULGPUState, texture_2_id) - 84usize];
    ["Offset of field: ULGPUState::texture_3_id"]
        [::std::mem::offset_of!(ULGPUState, texture_3_id) - 88usize];
    ["Offset of field: ULGPUState::uniform_scalar"]
        [::std::mem::offset_of!(ULGPUState, uniform_scalar) - 92usize];
    ["Offset of field: ULGPUState::uniform_vector"]
        [::std::mem::offset_of!(ULGPUState, uniform_vector) - 124usize];
    ["Offset of field: ULGPUState::clip_size"]
        [::std::mem::offset_of!(ULGPUState, clip_size) - 252usize];
    ["Offset of field: ULGPUState::clip"][::std::mem::offset_of!(ULGPUState, clip) - 256usize];
    ["Offset of field: ULGPUState::enable_scissor"]
        [::std::mem::offset_of!(ULGPUState, enable_scissor) - 768usize];
    ["Offset of field: ULGPUState::scissor_rect"]
        [::std::mem::offset_of!(ULGPUState, scissor_rect) - 772usize];
};
#[doc = "< Clear the specified render buffer."]
pub const ULCommandType_kCommandType_ClearRenderBuffer: ULCommandType = 0;
#[doc = "< Draw the specified geometry to the specified render buffer."]
pub const ULCommandType_kCommandType_DrawGeometry: ULCommandType = 1;
#[doc = "\n The types of commands.\n\n This enumeration describes the type of command to execute on the GPU. Used with\n ULCommand::command_type\n"]
pub type ULCommandType = ::std::os::raw::c_uint;
#[doc = "\n A command to execute on the GPU.\n\n This structure describes a command to be executed on the GPU.\n\n Commands are dispatched to the GPU driver asynchronously via ULGPUDriver::update_command_list,\n the GPU driver should consume these commands and execute them at an appropriate time.\n\n @see ULCommandList\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULCommand {
    #[doc = "< The type of command to dispatch."]
    pub command_type: ::std::os::raw::c_uchar,
    #[doc = "< The current GPU state."]
    pub gpu_state: ULGPUState,
    #[doc = "< The geometry ID to bind. (used with kCommandType_DrawGeometry)"]
    pub geometry_id: ::std::os::raw::c_uint,
    #[doc = "< The number of indices.   (used with kCommandType_DrawGeometry)"]
    pub indices_count: ::std::os::raw::c_uint,
    #[doc = "< The index to start from. (used with kCommandType_DrawGeometry)"]
    pub indices_offset: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULCommand"][::std::mem::size_of::<ULCommand>() - 804usize];
    ["Alignment of ULCommand"][::std::mem::align_of::<ULCommand>() - 4usize];
    ["Offset of field: ULCommand::command_type"]
        [::std::mem::offset_of!(ULCommand, command_type) - 0usize];
    ["Offset of field: ULCommand::gpu_state"]
        [::std::mem::offset_of!(ULCommand, gpu_state) - 4usize];
    ["Offset of field: ULCommand::geometry_id"]
        [::std::mem::offset_of!(ULCommand, geometry_id) - 792usize];
    ["Offset of field: ULCommand::indices_count"]
        [::std::mem::offset_of!(ULCommand, indices_count) - 796usize];
    ["Offset of field: ULCommand::indices_offset"]
        [::std::mem::offset_of!(ULCommand, indices_offset) - 800usize];
};
#[doc = "\n List of commands to execute on the GPU.\n\n @see ULGPUDriver::update_command_list\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ULCommandList {
    #[doc = "< The number of commands in the list."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< The raw command list data."]
    pub commands: *mut ULCommand,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULCommandList"][::std::mem::size_of::<ULCommandList>() - 16usize];
    ["Alignment of ULCommandList"][::std::mem::align_of::<ULCommandList>() - 8usize];
    ["Offset of field: ULCommandList::size"][::std::mem::offset_of!(ULCommandList, size) - 0usize];
    ["Offset of field: ULCommandList::commands"]
        [::std::mem::offset_of!(ULCommandList, commands) - 8usize];
};
impl Default for ULCommandList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n Callback for users to implement ULGPUDriver::begin_synchronize.\n\n Called before any state (eg, create_texture(), update_texture(), destroy_texture(), etc.) is\n updated during a call to ulRender().\n\n This is a good time to prepare the GPU for any state updates.\n"]
pub type ULGPUDriverBeginSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n Callback for users to implement ULGPUDriver::end_synchronize.\n\n Called after all state has been updated during a call to ulRender().\n"]
pub type ULGPUDriverEndSynchronizeCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = "\n Callback for users to implement ULGPUDriver::next_texture_id.\n\n Get the next available texture ID.\n\n This is used to generate a unique texture ID for each texture created by the library. The\n GPU driver implementation is responsible for mapping these IDs to a native ID.\n\n @note Numbering should start at 1, 0 is reserved for \"no texture\".\n\n @return Returns the next available texture ID.\n"]
pub type ULGPUDriverNextTextureIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n Callback for users to implement ULGPUDriver::create_texture.\n\n Create a texture with a certain ID and optional bitmap.\n\n @param texture_id  The texture ID to use for the new texture.\n\n @param bitmap      The bitmap to initialize the texture with (can be empty).\n\n @note If the Bitmap is empty (ulBitmapIsEmpty()), then a RTT Texture should be created instead.\n       This will be used as a backing texture for a new RenderBuffer.\n\n @warning A deep copy of the bitmap data should be made if you are uploading it to the GPU\n          asynchronously, it will not persist beyond this call.\n"]
pub type ULGPUDriverCreateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n Callback for users to implement ULGPUDriver::update_texture.\n\n Update an existing non-RTT texture with new bitmap data.\n\n @param texture_id  The texture to update.\n\n @param bitmap      The new bitmap data.\n\n @warning A deep copy of the bitmap data should be made if you are uploading it to the GPU\n          asynchronously, it will not persist beyond this call.\n"]
pub type ULGPUDriverUpdateTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint, bitmap: ULBitmap),
>;
#[doc = "\n Callback for users to implement ULGPUDriver::destroy_texture.\n\n Destroy a texture.\n\n @param texture_id  The texture to destroy.\n"]
pub type ULGPUDriverDestroyTextureCallback =
    ::std::option::Option<unsafe extern "C" fn(texture_id: ::std::os::raw::c_uint)>;
#[doc = "\n Callback for users to implement ULGPUDriver::next_render_buffer_id.\n\n Get the next available render buffer ID.\n\n This is used to generate a unique render buffer ID for each render buffer created by the\n library. The GPU driver implementation is responsible for mapping these IDs to a native ID.\n\n @note Numbering should start at 1, 0 is reserved for \"no render buffer\".\n\n @return Returns the next available render buffer ID.\n"]
pub type ULGPUDriverNextRenderBufferIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n Callback for users to implement ULGPUDriver::create_render_buffer.\n\n Create a render buffer with certain ID and buffer description.\n\n @param render_buffer_id  The render buffer ID to use for the new render buffer.\n\n @param buffer           The render buffer description.\n"]
pub type ULGPUDriverCreateRenderBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint, buffer: ULRenderBuffer),
>;
#[doc = "\n Callback for users to implement ULGPUDriver::destroy_render_buffer.\n\n Destroy a render buffer.\n\n @param render_buffer_id  The render buffer to destroy.\n"]
pub type ULGPUDriverDestroyRenderBufferCallback =
    ::std::option::Option<unsafe extern "C" fn(render_buffer_id: ::std::os::raw::c_uint)>;
#[doc = "\n Callback for users to implement ULGPUDriver::next_geometry_id.\n\n Get the next available geometry ID.\n\n This is used to generate a unique geometry ID for each geometry created by the library. The\n GPU driver implementation is responsible for mapping these IDs to a native ID.\n\n @note Numbering should start at 1, 0 is reserved for \"no geometry\".\n\n @return Returns the next available geometry ID.\n"]
pub type ULGPUDriverNextGeometryIdCallback =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = "\n Callback for users to implement ULGPUDriver::create_geometry.\n\n Create geometry with certain ID and vertex/index data.\n\n @param geometry_id  The geometry ID to use for the new geometry.\n\n @param vertices     The vertex buffer data.\n\n @param indices      The index buffer data.\n\n @warning A deep copy of the vertex/index data should be made if you are uploading it to the\n          GPU asynchronously, it will not persist beyond this call.\n"]
pub type ULGPUDriverCreateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n Callback for users to implement ULGPUDriver::update_geometry.\n\n Update existing geometry with new vertex/index data.\n\n @param geometry_id  The geometry to update.\n\n @param vertices     The new vertex buffer data.\n\n @param indices      The new index buffer data.\n\n @warning A deep copy of the vertex/index data should be made if you are uploading it to the\n          GPU asynchronously, it will not persist beyond this call.\n"]
pub type ULGPUDriverUpdateGeometryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        geometry_id: ::std::os::raw::c_uint,
        vertices: ULVertexBuffer,
        indices: ULIndexBuffer,
    ),
>;
#[doc = "\n Callback for users to implement ULGPUDriver::destroy_geometry.\n\n Destroy geometry.\n\n @param geometry_id  The geometry to destroy.\n"]
pub type ULGPUDriverDestroyGeometryCallback =
    ::std::option::Option<unsafe extern "C" fn(geometry_id: ::std::os::raw::c_uint)>;
#[doc = "\n Callback for users to implement ULGPUDriver::update_command_list.\n\n Update the pending command list with commands to execute on the GPU.\n\n Commands are dispatched to the GPU driver asynchronously via this method. The GPU driver\n implementation should consume these commands and execute them at an appropriate time.\n\n @param list  The list of commands to execute.\n\n @warning Implementations should make a deep copy of the command list, it will not persist\n          beyond this call.\n"]
pub type ULGPUDriverUpdateCommandListCallback =
    ::std::option::Option<unsafe extern "C" fn(list: ULCommandList)>;
#[doc = "\n User-defined GPU driver interface.\n\n You should implement each of these callbacks, then pass an instance of this struct containing\n your callbacks to ulPlatformSetGPUDriver().\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULGPUDriver {
    pub begin_synchronize: ULGPUDriverBeginSynchronizeCallback,
    pub end_synchronize: ULGPUDriverEndSynchronizeCallback,
    pub next_texture_id: ULGPUDriverNextTextureIdCallback,
    pub create_texture: ULGPUDriverCreateTextureCallback,
    pub update_texture: ULGPUDriverUpdateTextureCallback,
    pub destroy_texture: ULGPUDriverDestroyTextureCallback,
    pub next_render_buffer_id: ULGPUDriverNextRenderBufferIdCallback,
    pub create_render_buffer: ULGPUDriverCreateRenderBufferCallback,
    pub destroy_render_buffer: ULGPUDriverDestroyRenderBufferCallback,
    pub next_geometry_id: ULGPUDriverNextGeometryIdCallback,
    pub create_geometry: ULGPUDriverCreateGeometryCallback,
    pub update_geometry: ULGPUDriverUpdateGeometryCallback,
    pub destroy_geometry: ULGPUDriverDestroyGeometryCallback,
    pub update_command_list: ULGPUDriverUpdateCommandListCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULGPUDriver"][::std::mem::size_of::<ULGPUDriver>() - 112usize];
    ["Alignment of ULGPUDriver"][::std::mem::align_of::<ULGPUDriver>() - 8usize];
    ["Offset of field: ULGPUDriver::begin_synchronize"]
        [::std::mem::offset_of!(ULGPUDriver, begin_synchronize) - 0usize];
    ["Offset of field: ULGPUDriver::end_synchronize"]
        [::std::mem::offset_of!(ULGPUDriver, end_synchronize) - 8usize];
    ["Offset of field: ULGPUDriver::next_texture_id"]
        [::std::mem::offset_of!(ULGPUDriver, next_texture_id) - 16usize];
    ["Offset of field: ULGPUDriver::create_texture"]
        [::std::mem::offset_of!(ULGPUDriver, create_texture) - 24usize];
    ["Offset of field: ULGPUDriver::update_texture"]
        [::std::mem::offset_of!(ULGPUDriver, update_texture) - 32usize];
    ["Offset of field: ULGPUDriver::destroy_texture"]
        [::std::mem::offset_of!(ULGPUDriver, destroy_texture) - 40usize];
    ["Offset of field: ULGPUDriver::next_render_buffer_id"]
        [::std::mem::offset_of!(ULGPUDriver, next_render_buffer_id) - 48usize];
    ["Offset of field: ULGPUDriver::create_render_buffer"]
        [::std::mem::offset_of!(ULGPUDriver, create_render_buffer) - 56usize];
    ["Offset of field: ULGPUDriver::destroy_render_buffer"]
        [::std::mem::offset_of!(ULGPUDriver, destroy_render_buffer) - 64usize];
    ["Offset of field: ULGPUDriver::next_geometry_id"]
        [::std::mem::offset_of!(ULGPUDriver, next_geometry_id) - 72usize];
    ["Offset of field: ULGPUDriver::create_geometry"]
        [::std::mem::offset_of!(ULGPUDriver, create_geometry) - 80usize];
    ["Offset of field: ULGPUDriver::update_geometry"]
        [::std::mem::offset_of!(ULGPUDriver, update_geometry) - 88usize];
    ["Offset of field: ULGPUDriver::destroy_geometry"]
        [::std::mem::offset_of!(ULGPUDriver, destroy_geometry) - 96usize];
    ["Offset of field: ULGPUDriver::update_command_list"]
        [::std::mem::offset_of!(ULGPUDriver, update_command_list) - 104usize];
};
pub const ULLogLevel_kLogLevel_Error: ULLogLevel = 0;
pub const ULLogLevel_kLogLevel_Warning: ULLogLevel = 1;
pub const ULLogLevel_kLogLevel_Info: ULLogLevel = 2;
#[doc = " Logger"]
pub type ULLogLevel = ::std::os::raw::c_uint;
#[doc = "\n The callback invoked when the library wants to print a message to the log.\n"]
pub type ULLoggerLogMessageCallback =
    ::std::option::Option<unsafe extern "C" fn(log_level: ULLogLevel, message: ULString)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULLogger {
    pub log_message: ULLoggerLogMessageCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULLogger"][::std::mem::size_of::<ULLogger>() - 8usize];
    ["Alignment of ULLogger"][::std::mem::align_of::<ULLogger>() - 8usize];
    ["Offset of field: ULLogger::log_message"]
        [::std::mem::offset_of!(ULLogger, log_message) - 0usize];
};
#[doc = "\n The callback invoked when a Surface is created.\n\n @param  width  The width in pixels.\n @param  height  The height in pixels.\n\n @return  This callback should return a pointer to user-defined data for the instance. This user\n          data pointer will be passed to all other callbacks when operating on the instance.\n"]
pub type ULSurfaceDefinitionCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface is destroyed.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionDestroyCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface's width (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetWidthCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's height (in pixels) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetHeightCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's row bytes is requested.\n\n @note  This value is also known as \"stride\". Usually width * 4.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetRowBytesCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
#[doc = "\n The callback invoked when a Surface's size (in bytes) is requested.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionGetSizeCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> usize>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be locked for reading/writing\n (should return a pointer to locked bytes).\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionLockPixelsCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = "\n The callback invoked when a Surface's pixel buffer is requested to be unlocked after previously\n being locked.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n"]
pub type ULSurfaceDefinitionUnlockPixelsCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "\n The callback invoked when a Surface is requested to be resized to a certain width/height.\n\n @param  user_data  User data pointer uniquely identifying the surface.\n\n @param  width      Width in pixels.\n\n @param  height     Height in pixels.\n"]
pub type ULSurfaceDefinitionResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
#[doc = "\n User-defined surface interface.\n\n You should implement each of these callbacks, then pass an instance of this struct containing\n your callbacks to ulPlatformSetSurfaceDefinition().\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ULSurfaceDefinition {
    pub create: ULSurfaceDefinitionCreateCallback,
    pub destroy: ULSurfaceDefinitionDestroyCallback,
    pub get_width: ULSurfaceDefinitionGetWidthCallback,
    pub get_height: ULSurfaceDefinitionGetHeightCallback,
    pub get_row_bytes: ULSurfaceDefinitionGetRowBytesCallback,
    pub get_size: ULSurfaceDefinitionGetSizeCallback,
    pub lock_pixels: ULSurfaceDefinitionLockPixelsCallback,
    pub unlock_pixels: ULSurfaceDefinitionUnlockPixelsCallback,
    pub resize: ULSurfaceDefinitionResizeCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ULSurfaceDefinition"][::std::mem::size_of::<ULSurfaceDefinition>() - 72usize];
    ["Alignment of ULSurfaceDefinition"][::std::mem::align_of::<ULSurfaceDefinition>() - 8usize];
    ["Offset of field: ULSurfaceDefinition::create"]
        [::std::mem::offset_of!(ULSurfaceDefinition, create) - 0usize];
    ["Offset of field: ULSurfaceDefinition::destroy"]
        [::std::mem::offset_of!(ULSurfaceDefinition, destroy) - 8usize];
    ["Offset of field: ULSurfaceDefinition::get_width"]
        [::std::mem::offset_of!(ULSurfaceDefinition, get_width) - 16usize];
    ["Offset of field: ULSurfaceDefinition::get_height"]
        [::std::mem::offset_of!(ULSurfaceDefinition, get_height) - 24usize];
    ["Offset of field: ULSurfaceDefinition::get_row_bytes"]
        [::std::mem::offset_of!(ULSurfaceDefinition, get_row_bytes) - 32usize];
    ["Offset of field: ULSurfaceDefinition::get_size"]
        [::std::mem::offset_of!(ULSurfaceDefinition, get_size) - 40usize];
    ["Offset of field: ULSurfaceDefinition::lock_pixels"]
        [::std::mem::offset_of!(ULSurfaceDefinition, lock_pixels) - 48usize];
    ["Offset of field: ULSurfaceDefinition::unlock_pixels"]
        [::std::mem::offset_of!(ULSurfaceDefinition, unlock_pixels) - 56usize];
    ["Offset of field: ULSurfaceDefinition::resize"]
        [::std::mem::offset_of!(ULSurfaceDefinition, resize) - 64usize];
};
pub type ULChangeTitleCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, title: ULString),
>;
pub type ULChangeURLCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, url: ULString),
>;
pub type ULChangeTooltipCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, tooltip: ULString),
>;
pub type ULChangeCursorCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView, cursor: ULCursor),
>;
pub type ULAddConsoleMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        source: ULMessageSource,
        level: ULMessageLevel,
        message: ULString,
        line_number: ::std::os::raw::c_uint,
        column_number: ::std::os::raw::c_uint,
        source_id: ULString,
    ),
>;
pub type ULCreateChildViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        opener_url: ULString,
        target_url: ULString,
        is_popup: bool,
        popup_rect: ULIntRect,
    ) -> ULView,
>;
pub type ULCreateInspectorViewCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        is_local: bool,
        inspected_url: ULString,
    ) -> ULView,
>;
pub type ULBeginLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
pub type ULFinishLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
pub type ULFailLoadingCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
        description: ULString,
        error_domain: ULString,
        error_code: ::std::os::raw::c_int,
    ),
>;
pub type ULWindowObjectReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
pub type ULDOMReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        caller: ULView,
        frame_id: ::std::os::raw::c_ulonglong,
        is_main_frame: bool,
        url: ULString,
    ),
>;
pub type ULUpdateHistoryCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, caller: ULView),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Settings {
    _unused: [u8; 0],
}
pub type ULSettings = *mut C_Settings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_App {
    _unused: [u8; 0],
}
pub type ULApp = *mut C_App;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Window {
    _unused: [u8; 0],
}
pub type ULWindow = *mut C_Window;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Monitor {
    _unused: [u8; 0],
}
pub type ULMonitor = *mut C_Monitor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C_Overlay {
    _unused: [u8; 0],
}
pub type ULOverlay = *mut C_Overlay;
pub const ULWindowFlags_kWindowFlags_Borderless: ULWindowFlags = 1;
pub const ULWindowFlags_kWindowFlags_Titled: ULWindowFlags = 2;
pub const ULWindowFlags_kWindowFlags_Resizable: ULWindowFlags = 4;
pub const ULWindowFlags_kWindowFlags_Maximizable: ULWindowFlags = 8;
pub const ULWindowFlags_kWindowFlags_Hidden: ULWindowFlags = 16;
#[doc = "\n Window creation flags. @see Window::Create\n"]
pub type ULWindowFlags = ::std::os::raw::c_uint;
pub type ULUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
pub type ULCloseCallback = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, window: ULWindow),
>;
pub type ULResizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ),
>;
