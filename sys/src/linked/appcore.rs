/* automatically generated by rust-bindgen 0.70.1 */

use crate::defines::*;

extern "C" {
    #[doc = "\n Create settings with default values (see <AppCore/App.h>).\n"]
    pub fn ulCreateSettings() -> ULSettings;
}
extern "C" {
    #[doc = "\n Destroy settings.\n"]
    pub fn ulDestroySettings(settings: ULSettings);
}
extern "C" {
    #[doc = "\n Set the name of the developer of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyCompany\"\n"]
    pub fn ulSettingsSetDeveloperName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the name of this app.\n\n This is used to generate a unique path to store local application data\n on the user's machine.\n\n Default is \"MyApp\"\n"]
    pub fn ulSettingsSetAppName(settings: ULSettings, name: ULString);
}
extern "C" {
    #[doc = "\n Set the root file path for our file system, you should set this to the\n relative path where all of your app data is.\n\n This will be used to resolve all file URLs, eg file:///page.html\n\n @note  The default path is \"./assets/\"\n\n        This relative path is resolved using the following logic:\n         - Windows: relative to the executable path\n         - Linux:   relative to the executable path\n         - macOS:   relative to YourApp.app/Contents/Resources/\n"]
    pub fn ulSettingsSetFileSystemPath(settings: ULSettings, path: ULString);
}
extern "C" {
    #[doc = "\n Set whether or not we should load and compile shaders from the file system\n (eg, from the /shaders/ path, relative to file_system_path).\n\n If this is false (the default), we will instead load pre-compiled shaders\n from memory which speeds up application startup time.\n"]
    pub fn ulSettingsSetLoadShadersFromFileSystem(settings: ULSettings, enabled: bool);
}
extern "C" {
    #[doc = "\n We try to use the GPU renderer when a compatible GPU is detected.\n\n Set this to true to force the engine to always use the CPU renderer.\n"]
    pub fn ulSettingsSetForceCPURenderer(settings: ULSettings, force_cpu: bool);
}
extern "C" {
    #[doc = "\n Create the App singleton.\n\n @param  settings  Settings to customize App runtime behavior. You can pass\n                   NULL for this parameter to use default settings.\n\n @param  config  Config options for the Ultralight renderer. You can pass\n                 NULL for this parameter to use default config.\n\n @note  You should only create one of these per application lifetime.\n\n @note  Certain Config options may be overridden during App creation,\n        most commonly Config::face_winding and Config::device_scale_hint.\n"]
    pub fn ulCreateApp(settings: ULSettings, config: ULConfig) -> ULApp;
}
extern "C" {
    #[doc = "\n Destroy the App instance.\n"]
    pub fn ulDestroyApp(app: ULApp);
}
extern "C" {
    #[doc = "\n Set a callback for whenever the App updates. You should update all app\n logic here.\n\n @note  This event is fired right before the run loop calls\n        Renderer::Update and Renderer::Render.\n"]
    pub fn ulAppSetUpdateCallback(
        app: ULApp,
        callback: ULUpdateCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Whether or not the App is running.\n"]
    pub fn ulAppIsRunning(app: ULApp) -> bool;
}
extern "C" {
    #[doc = "\n Get the main monitor (this is never NULL).\n\n @note  We'll add monitor enumeration later.\n"]
    pub fn ulAppGetMainMonitor(app: ULApp) -> ULMonitor;
}
extern "C" {
    #[doc = "\n Get the underlying Renderer instance.\n"]
    pub fn ulAppGetRenderer(app: ULApp) -> ULRenderer;
}
extern "C" {
    #[doc = "\n Run the main loop.\n"]
    pub fn ulAppRun(app: ULApp);
}
extern "C" {
    #[doc = "\n Quit the application.\n"]
    pub fn ulAppQuit(app: ULApp);
}
extern "C" {
    #[doc = "\n Get the monitor's DPI scale (1.0 = 100%).\n"]
    pub fn ulMonitorGetScale(monitor: ULMonitor) -> f64;
}
extern "C" {
    #[doc = "\n Get the width of the monitor (in pixels).\n"]
    pub fn ulMonitorGetWidth(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height of the monitor (in pixels).\n"]
    pub fn ulMonitorGetHeight(monitor: ULMonitor) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Create a new Window.\n\n @param  monitor       The monitor to create the Window on.\n\n @param  width         The width (in screen coordinates).\n\n @param  height        The height (in screen coordinates).\n\n @param  fullscreen    Whether or not the window is fullscreen.\n\n @param  window_flags  Various window flags.\n"]
    pub fn ulCreateWindow(
        monitor: ULMonitor,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        fullscreen: bool,
        window_flags: ::std::os::raw::c_uint,
    ) -> ULWindow;
}
extern "C" {
    #[doc = "\n Destroy a Window.\n"]
    pub fn ulDestroyWindow(window: ULWindow);
}
extern "C" {
    #[doc = "\n Set a callback to be notified when a window closes.\n"]
    pub fn ulWindowSetCloseCallback(
        window: ULWindow,
        callback: ULCloseCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Set a callback to be notified when a window resizes\n (parameters are passed back in pixels).\n"]
    pub fn ulWindowSetResizeCallback(
        window: ULWindow,
        callback: ULResizeCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\n Get window width (in screen coordinates).\n"]
    pub fn ulWindowGetScreenWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window width (in pixels).\n"]
    pub fn ulWindowGetWidth(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in screen coordinates).\n"]
    pub fn ulWindowGetScreenHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get window height (in pixels).\n"]
    pub fn ulWindowGetHeight(window: ULWindow) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Move the window to a new position (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowMoveTo(window: ULWindow, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Move the window to the center of the monitor.\n"]
    pub fn ulWindowMoveToCenter(arg1: ULWindow);
}
extern "C" {
    #[doc = "\n Get the x-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionX(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position of the window (in screen coordinates) relative to the top-left of the\n monitor area.\n"]
    pub fn ulWindowGetPositionY(window: ULWindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get whether or not a window is fullscreen.\n"]
    pub fn ulWindowIsFullscreen(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Get the DPI scale of a window.\n"]
    pub fn ulWindowGetScale(window: ULWindow) -> f64;
}
extern "C" {
    #[doc = "\n Set the window title.\n"]
    pub fn ulWindowSetTitle(window: ULWindow, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\n Set the cursor for a window.\n"]
    pub fn ulWindowSetCursor(window: ULWindow, cursor: ULCursor);
}
extern "C" {
    #[doc = "\n Show the window (if it was previously hidden).\n"]
    pub fn ulWindowShow(window: ULWindow);
}
extern "C" {
    #[doc = "\n Hide the window.\n"]
    pub fn ulWindowHide(window: ULWindow);
}
extern "C" {
    #[doc = "\n Whether or not the window is currently visible (not hidden).\n"]
    pub fn ulWindowIsVisible(window: ULWindow) -> bool;
}
extern "C" {
    #[doc = "\n Close a window.\n"]
    pub fn ulWindowClose(window: ULWindow);
}
extern "C" {
    #[doc = "\n Convert screen coordinates to pixels using the current DPI scale.\n"]
    pub fn ulWindowScreenToPixels(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Convert pixels to screen coordinates using the current DPI scale.\n"]
    pub fn ulWindowPixelsToScreen(
        window: ULWindow,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the underlying native window handle.\n\n @note This is:  - HWND on Windows\n                 - NSWindow* on macOS\n                 - GLFWwindow* on Linux\n"]
    pub fn ulWindowGetNativeHandle(window: ULWindow) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "\n Create a new Overlay.\n\n @param  window  The window to create the Overlay in.\n\n @param  width   The width in pixels.\n\n @param  height  The height in pixels.\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlay(
        window: ULWindow,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Create a new Overlay, wrapping an existing View.\n\n @param  window  The window to create the Overlay in. (we currently only\n                 support one window per application)\n\n @param  view    The View to wrap (will use its width and height).\n\n @param  x       The x-position (offset from the left of the Window), in\n                 pixels.\n\n @param  y       The y-position (offset from the top of the Window), in\n                 pixels.\n\n @note  Each Overlay is essentially a View and an on-screen quad. You should\n        create the Overlay then load content into the underlying View.\n"]
    pub fn ulCreateOverlayWithView(
        window: ULWindow,
        view: ULView,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ULOverlay;
}
extern "C" {
    #[doc = "\n Destroy an overlay.\n"]
    pub fn ulDestroyOverlay(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Get the underlying View.\n"]
    pub fn ulOverlayGetView(overlay: ULOverlay) -> ULView;
}
extern "C" {
    #[doc = "\n Get the width (in pixels).\n"]
    pub fn ulOverlayGetWidth(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the height (in pixels).\n"]
    pub fn ulOverlayGetHeight(overlay: ULOverlay) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\n Get the x-position (offset from the left of the Window), in pixels.\n"]
    pub fn ulOverlayGetX(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Get the y-position (offset from the top of the Window), in pixels.\n"]
    pub fn ulOverlayGetY(overlay: ULOverlay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Move the overlay to a new position (in pixels).\n"]
    pub fn ulOverlayMoveTo(overlay: ULOverlay, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\n Resize the overlay (and underlying View), dimensions should be\n specified in pixels.\n"]
    pub fn ulOverlayResize(
        overlay: ULOverlay,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "\n Whether or not the overlay is hidden (not drawn).\n"]
    pub fn ulOverlayIsHidden(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Hide the overlay (will no longer be drawn).\n"]
    pub fn ulOverlayHide(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Show the overlay.\n"]
    pub fn ulOverlayShow(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Whether or not an overlay has keyboard focus.\n"]
    pub fn ulOverlayHasFocus(overlay: ULOverlay) -> bool;
}
extern "C" {
    #[doc = "\n Grant this overlay exclusive keyboard focus.\n"]
    pub fn ulOverlayFocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n Remove keyboard focus.\n"]
    pub fn ulOverlayUnfocus(overlay: ULOverlay);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform font loader and sets it as the current FontLoader.\n"]
    pub fn ulEnablePlatformFontLoader();
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the platform file system (needed for loading file:/// URLs) and\n sets it as the current FileSystem.\n\n You can specify a base directory path to resolve relative paths against.\n"]
    pub fn ulEnablePlatformFileSystem(base_dir: ULString);
}
extern "C" {
    #[doc = "\n This is only needed if you are not calling ulCreateApp().\n\n Initializes the default logger (writes the log to a file).\n\n You should specify a writable log path to write the log to\n for example \"./ultralight.log\".\n"]
    pub fn ulEnableDefaultLogger(log_path: ULString);
}
